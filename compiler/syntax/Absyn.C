/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   Program    ********************/
Program::Program(ListDecl *p1, ListStatement *p2)
{
  listdecl_ = p1;
  liststatement_ = p2;

}

Program::Program(const Program & other)
{
  listdecl_ = other.listdecl_->clone();
  liststatement_ = other.liststatement_->clone();

}

Program &Program::operator=(const Program & other)
{
  Program tmp(other);
  swap(tmp);
  return *this;
}

void Program::swap(Program & other)
{
  std::swap(listdecl_, other.listdecl_);
  std::swap(liststatement_, other.liststatement_);

}

Program::~Program()
{
  delete(listdecl_);
  delete(liststatement_);

}

void Program::accept(Visitor *v)
{
  v->visitProgram(this);
}

Program *Program::clone() const
{
  return new Program(*this);
}



/********************   Declaration    ********************/
Declaration::Declaration(Ident p1, TypeReference *p2)
{
  ident_ = p1;
  typereference_ = p2;

}

Declaration::Declaration(const Declaration & other)
{
  ident_ = other.ident_;
  typereference_ = other.typereference_->clone();

}

Declaration &Declaration::operator=(const Declaration & other)
{
  Declaration tmp(other);
  swap(tmp);
  return *this;
}

void Declaration::swap(Declaration & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typereference_, other.typereference_);

}

Declaration::~Declaration()
{
  delete(typereference_);

}

void Declaration::accept(Visitor *v)
{
  v->visitDeclaration(this);
}

Declaration *Declaration::clone() const
{
  return new Declaration(*this);
}



/********************   NothingType    ********************/
NothingType::NothingType()
{

}

NothingType::NothingType(const NothingType & other)
{

}

NothingType &NothingType::operator=(const NothingType & other)
{
  NothingType tmp(other);
  swap(tmp);
  return *this;
}

void NothingType::swap(NothingType & other)
{

}

NothingType::~NothingType()
{

}

void NothingType::accept(Visitor *v)
{
  v->visitNothingType(this);
}

NothingType *NothingType::clone() const
{
  return new NothingType(*this);
}



/********************   BoolType    ********************/
BoolType::BoolType()
{

}

BoolType::BoolType(const BoolType & other)
{

}

BoolType &BoolType::operator=(const BoolType & other)
{
  BoolType tmp(other);
  swap(tmp);
  return *this;
}

void BoolType::swap(BoolType & other)
{

}

BoolType::~BoolType()
{

}

void BoolType::accept(Visitor *v)
{
  v->visitBoolType(this);
}

BoolType *BoolType::clone() const
{
  return new BoolType(*this);
}



/********************   IntegerType    ********************/
IntegerType::IntegerType()
{

}

IntegerType::IntegerType(const IntegerType & other)
{

}

IntegerType &IntegerType::operator=(const IntegerType & other)
{
  IntegerType tmp(other);
  swap(tmp);
  return *this;
}

void IntegerType::swap(IntegerType & other)
{

}

IntegerType::~IntegerType()
{

}

void IntegerType::accept(Visitor *v)
{
  v->visitIntegerType(this);
}

IntegerType *IntegerType::clone() const
{
  return new IntegerType(*this);
}



/********************   DoubleType    ********************/
DoubleType::DoubleType()
{

}

DoubleType::DoubleType(const DoubleType & other)
{

}

DoubleType &DoubleType::operator=(const DoubleType & other)
{
  DoubleType tmp(other);
  swap(tmp);
  return *this;
}

void DoubleType::swap(DoubleType & other)
{

}

DoubleType::~DoubleType()
{

}

void DoubleType::accept(Visitor *v)
{
  v->visitDoubleType(this);
}

DoubleType *DoubleType::clone() const
{
  return new DoubleType(*this);
}



/********************   StringType    ********************/
StringType::StringType()
{

}

StringType::StringType(const StringType & other)
{

}

StringType &StringType::operator=(const StringType & other)
{
  StringType tmp(other);
  swap(tmp);
  return *this;
}

void StringType::swap(StringType & other)
{

}

StringType::~StringType()
{

}

void StringType::accept(Visitor *v)
{
  v->visitStringType(this);
}

StringType *StringType::clone() const
{
  return new StringType(*this);
}



/********************   AutoType    ********************/
AutoType::AutoType()
{

}

AutoType::AutoType(const AutoType & other)
{

}

AutoType &AutoType::operator=(const AutoType & other)
{
  AutoType tmp(other);
  swap(tmp);
  return *this;
}

void AutoType::swap(AutoType & other)
{

}

AutoType::~AutoType()
{

}

void AutoType::accept(Visitor *v)
{
  v->visitAutoType(this);
}

AutoType *AutoType::clone() const
{
  return new AutoType(*this);
}



/********************   FunctionDeclType    ********************/
FunctionDeclType::FunctionDeclType(FuncDecl *p1)
{
  funcdecl_ = p1;

}

FunctionDeclType::FunctionDeclType(const FunctionDeclType & other)
{
  funcdecl_ = other.funcdecl_->clone();

}

FunctionDeclType &FunctionDeclType::operator=(const FunctionDeclType & other)
{
  FunctionDeclType tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDeclType::swap(FunctionDeclType & other)
{
  std::swap(funcdecl_, other.funcdecl_);

}

FunctionDeclType::~FunctionDeclType()
{
  delete(funcdecl_);

}

void FunctionDeclType::accept(Visitor *v)
{
  v->visitFunctionDeclType(this);
}

FunctionDeclType *FunctionDeclType::clone() const
{
  return new FunctionDeclType(*this);
}



/********************   FunctionDefType    ********************/
FunctionDefType::FunctionDefType(FuncDefn *p1)
{
  funcdefn_ = p1;

}

FunctionDefType::FunctionDefType(const FunctionDefType & other)
{
  funcdefn_ = other.funcdefn_->clone();

}

FunctionDefType &FunctionDefType::operator=(const FunctionDefType & other)
{
  FunctionDefType tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefType::swap(FunctionDefType & other)
{
  std::swap(funcdefn_, other.funcdefn_);

}

FunctionDefType::~FunctionDefType()
{
  delete(funcdefn_);

}

void FunctionDefType::accept(Visitor *v)
{
  v->visitFunctionDefType(this);
}

FunctionDefType *FunctionDefType::clone() const
{
  return new FunctionDefType(*this);
}



/********************   ArrayType    ********************/
ArrayType::ArrayType(TypeReference *p1)
{
  typereference_ = p1;

}

ArrayType::ArrayType(const ArrayType & other)
{
  typereference_ = other.typereference_->clone();

}

ArrayType &ArrayType::operator=(const ArrayType & other)
{
  ArrayType tmp(other);
  swap(tmp);
  return *this;
}

void ArrayType::swap(ArrayType & other)
{
  std::swap(typereference_, other.typereference_);

}

ArrayType::~ArrayType()
{
  delete(typereference_);

}

void ArrayType::accept(Visitor *v)
{
  v->visitArrayType(this);
}

ArrayType *ArrayType::clone() const
{
  return new ArrayType(*this);
}



/********************   ClassType    ********************/
ClassType::ClassType(ClassDecl *p1)
{
  classdecl_ = p1;

}

ClassType::ClassType(const ClassType & other)
{
  classdecl_ = other.classdecl_->clone();

}

ClassType &ClassType::operator=(const ClassType & other)
{
  ClassType tmp(other);
  swap(tmp);
  return *this;
}

void ClassType::swap(ClassType & other)
{
  std::swap(classdecl_, other.classdecl_);

}

ClassType::~ClassType()
{
  delete(classdecl_);

}

void ClassType::accept(Visitor *v)
{
  v->visitClassType(this);
}

ClassType *ClassType::clone() const
{
  return new ClassType(*this);
}



/********************   UserType    ********************/
UserType::UserType(Ident p1)
{
  ident_ = p1;

}

UserType::UserType(const UserType & other)
{
  ident_ = other.ident_;

}

UserType &UserType::operator=(const UserType & other)
{
  UserType tmp(other);
  swap(tmp);
  return *this;
}

void UserType::swap(UserType & other)
{
  std::swap(ident_, other.ident_);

}

UserType::~UserType()
{

}

void UserType::accept(Visitor *v)
{
  v->visitUserType(this);
}

UserType *UserType::clone() const
{
  return new UserType(*this);
}



/********************   ClassDeclaration    ********************/
ClassDeclaration::ClassDeclaration(Extends *p1, Statics *p2, CBody *p3)
{
  extends_ = p1;
  statics_ = p2;
  cbody_ = p3;

}

ClassDeclaration::ClassDeclaration(const ClassDeclaration & other)
{
  extends_ = other.extends_->clone();
  statics_ = other.statics_->clone();
  cbody_ = other.cbody_->clone();

}

ClassDeclaration &ClassDeclaration::operator=(const ClassDeclaration & other)
{
  ClassDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void ClassDeclaration::swap(ClassDeclaration & other)
{
  std::swap(extends_, other.extends_);
  std::swap(statics_, other.statics_);
  std::swap(cbody_, other.cbody_);

}

ClassDeclaration::~ClassDeclaration()
{
  delete(extends_);
  delete(statics_);
  delete(cbody_);

}

void ClassDeclaration::accept(Visitor *v)
{
  v->visitClassDeclaration(this);
}

ClassDeclaration *ClassDeclaration::clone() const
{
  return new ClassDeclaration(*this);
}



/********************   ExtendsEmpty    ********************/
ExtendsEmpty::ExtendsEmpty()
{

}

ExtendsEmpty::ExtendsEmpty(const ExtendsEmpty & other)
{

}

ExtendsEmpty &ExtendsEmpty::operator=(const ExtendsEmpty & other)
{
  ExtendsEmpty tmp(other);
  swap(tmp);
  return *this;
}

void ExtendsEmpty::swap(ExtendsEmpty & other)
{

}

ExtendsEmpty::~ExtendsEmpty()
{

}

void ExtendsEmpty::accept(Visitor *v)
{
  v->visitExtendsEmpty(this);
}

ExtendsEmpty *ExtendsEmpty::clone() const
{
  return new ExtendsEmpty(*this);
}



/********************   ExtendsList    ********************/
ExtendsList::ExtendsList(Ident p1)
{
  ident_ = p1;

}

ExtendsList::ExtendsList(const ExtendsList & other)
{
  ident_ = other.ident_;

}

ExtendsList &ExtendsList::operator=(const ExtendsList & other)
{
  ExtendsList tmp(other);
  swap(tmp);
  return *this;
}

void ExtendsList::swap(ExtendsList & other)
{
  std::swap(ident_, other.ident_);

}

ExtendsList::~ExtendsList()
{

}

void ExtendsList::accept(Visitor *v)
{
  v->visitExtendsList(this);
}

ExtendsList *ExtendsList::clone() const
{
  return new ExtendsList(*this);
}



/********************   FieldDeclaration    ********************/
FieldDeclaration::FieldDeclaration(Ident p1, TypeReference *p2)
{
  ident_ = p1;
  typereference_ = p2;

}

FieldDeclaration::FieldDeclaration(const FieldDeclaration & other)
{
  ident_ = other.ident_;
  typereference_ = other.typereference_->clone();

}

FieldDeclaration &FieldDeclaration::operator=(const FieldDeclaration & other)
{
  FieldDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void FieldDeclaration::swap(FieldDeclaration & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typereference_, other.typereference_);

}

FieldDeclaration::~FieldDeclaration()
{
  delete(typereference_);

}

void FieldDeclaration::accept(Visitor *v)
{
  v->visitFieldDeclaration(this);
}

FieldDeclaration *FieldDeclaration::clone() const
{
  return new FieldDeclaration(*this);
}



/********************   FieldDefinition    ********************/
FieldDefinition::FieldDefinition(Ident p1, Value *p2)
{
  ident_ = p1;
  value_ = p2;

}

FieldDefinition::FieldDefinition(const FieldDefinition & other)
{
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

FieldDefinition &FieldDefinition::operator=(const FieldDefinition & other)
{
  FieldDefinition tmp(other);
  swap(tmp);
  return *this;
}

void FieldDefinition::swap(FieldDefinition & other)
{
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

FieldDefinition::~FieldDefinition()
{
  delete(value_);

}

void FieldDefinition::accept(Visitor *v)
{
  v->visitFieldDefinition(this);
}

FieldDefinition *FieldDefinition::clone() const
{
  return new FieldDefinition(*this);
}



/********************   FieldDefinitionAsc    ********************/
FieldDefinitionAsc::FieldDefinitionAsc(Ident p1, TypeReference *p2, Value *p3)
{
  ident_ = p1;
  typereference_ = p2;
  value_ = p3;

}

FieldDefinitionAsc::FieldDefinitionAsc(const FieldDefinitionAsc & other)
{
  ident_ = other.ident_;
  typereference_ = other.typereference_->clone();
  value_ = other.value_->clone();

}

FieldDefinitionAsc &FieldDefinitionAsc::operator=(const FieldDefinitionAsc & other)
{
  FieldDefinitionAsc tmp(other);
  swap(tmp);
  return *this;
}

void FieldDefinitionAsc::swap(FieldDefinitionAsc & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typereference_, other.typereference_);
  std::swap(value_, other.value_);

}

FieldDefinitionAsc::~FieldDefinitionAsc()
{
  delete(typereference_);
  delete(value_);

}

void FieldDefinitionAsc::accept(Visitor *v)
{
  v->visitFieldDefinitionAsc(this);
}

FieldDefinitionAsc *FieldDefinitionAsc::clone() const
{
  return new FieldDefinitionAsc(*this);
}



/********************   StaticsEmpty    ********************/
StaticsEmpty::StaticsEmpty()
{

}

StaticsEmpty::StaticsEmpty(const StaticsEmpty & other)
{

}

StaticsEmpty &StaticsEmpty::operator=(const StaticsEmpty & other)
{
  StaticsEmpty tmp(other);
  swap(tmp);
  return *this;
}

void StaticsEmpty::swap(StaticsEmpty & other)
{

}

StaticsEmpty::~StaticsEmpty()
{

}

void StaticsEmpty::accept(Visitor *v)
{
  v->visitStaticsEmpty(this);
}

StaticsEmpty *StaticsEmpty::clone() const
{
  return new StaticsEmpty(*this);
}



/********************   StaticsBody    ********************/
StaticsBody::StaticsBody(ListFieldDef *p1)
{
  listfielddef_ = p1;

}

StaticsBody::StaticsBody(const StaticsBody & other)
{
  listfielddef_ = other.listfielddef_->clone();

}

StaticsBody &StaticsBody::operator=(const StaticsBody & other)
{
  StaticsBody tmp(other);
  swap(tmp);
  return *this;
}

void StaticsBody::swap(StaticsBody & other)
{
  std::swap(listfielddef_, other.listfielddef_);

}

StaticsBody::~StaticsBody()
{
  delete(listfielddef_);

}

void StaticsBody::accept(Visitor *v)
{
  v->visitStaticsBody(this);
}

StaticsBody *StaticsBody::clone() const
{
  return new StaticsBody(*this);
}



/********************   ClassBody    ********************/
ClassBody::ClassBody(ListFieldDef *p1)
{
  listfielddef_ = p1;

}

ClassBody::ClassBody(const ClassBody & other)
{
  listfielddef_ = other.listfielddef_->clone();

}

ClassBody &ClassBody::operator=(const ClassBody & other)
{
  ClassBody tmp(other);
  swap(tmp);
  return *this;
}

void ClassBody::swap(ClassBody & other)
{
  std::swap(listfielddef_, other.listfielddef_);

}

ClassBody::~ClassBody()
{
  delete(listfielddef_);

}

void ClassBody::accept(Visitor *v)
{
  v->visitClassBody(this);
}

ClassBody *ClassBody::clone() const
{
  return new ClassBody(*this);
}



/********************   FunctionDeclaration    ********************/
FunctionDeclaration::FunctionDeclaration(FuncRange *p1, FuncDomain *p2)
{
  funcrange_ = p1;
  funcdomain_ = p2;

}

FunctionDeclaration::FunctionDeclaration(const FunctionDeclaration & other)
{
  funcrange_ = other.funcrange_->clone();
  funcdomain_ = other.funcdomain_->clone();

}

FunctionDeclaration &FunctionDeclaration::operator=(const FunctionDeclaration & other)
{
  FunctionDeclaration tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDeclaration::swap(FunctionDeclaration & other)
{
  std::swap(funcrange_, other.funcrange_);
  std::swap(funcdomain_, other.funcdomain_);

}

FunctionDeclaration::~FunctionDeclaration()
{
  delete(funcrange_);
  delete(funcdomain_);

}

void FunctionDeclaration::accept(Visitor *v)
{
  v->visitFunctionDeclaration(this);
}

FunctionDeclaration *FunctionDeclaration::clone() const
{
  return new FunctionDeclaration(*this);
}



/********************   FunctionDefinition    ********************/
FunctionDefinition::FunctionDefinition(FuncRangeNamed *p1, FuncDomain *p2, Body_ *p3)
{
  funcrangenamed_ = p1;
  funcdomain_ = p2;
  body__ = p3;

}

FunctionDefinition::FunctionDefinition(const FunctionDefinition & other)
{
  funcrangenamed_ = other.funcrangenamed_->clone();
  funcdomain_ = other.funcdomain_->clone();
  body__ = other.body__->clone();

}

FunctionDefinition &FunctionDefinition::operator=(const FunctionDefinition & other)
{
  FunctionDefinition tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDefinition::swap(FunctionDefinition & other)
{
  std::swap(funcrangenamed_, other.funcrangenamed_);
  std::swap(funcdomain_, other.funcdomain_);
  std::swap(body__, other.body__);

}

FunctionDefinition::~FunctionDefinition()
{
  delete(funcrangenamed_);
  delete(funcdomain_);
  delete(body__);

}

void FunctionDefinition::accept(Visitor *v)
{
  v->visitFunctionDefinition(this);
}

FunctionDefinition *FunctionDefinition::clone() const
{
  return new FunctionDefinition(*this);
}



/********************   FunctionDomain    ********************/
FunctionDomain::FunctionDomain(TypeReference *p1)
{
  typereference_ = p1;

}

FunctionDomain::FunctionDomain(const FunctionDomain & other)
{
  typereference_ = other.typereference_->clone();

}

FunctionDomain &FunctionDomain::operator=(const FunctionDomain & other)
{
  FunctionDomain tmp(other);
  swap(tmp);
  return *this;
}

void FunctionDomain::swap(FunctionDomain & other)
{
  std::swap(typereference_, other.typereference_);

}

FunctionDomain::~FunctionDomain()
{
  delete(typereference_);

}

void FunctionDomain::accept(Visitor *v)
{
  v->visitFunctionDomain(this);
}

FunctionDomain *FunctionDomain::clone() const
{
  return new FunctionDomain(*this);
}



/********************   FunctionRangeSingle    ********************/
FunctionRangeSingle::FunctionRangeSingle(TypeReference *p1)
{
  typereference_ = p1;

}

FunctionRangeSingle::FunctionRangeSingle(const FunctionRangeSingle & other)
{
  typereference_ = other.typereference_->clone();

}

FunctionRangeSingle &FunctionRangeSingle::operator=(const FunctionRangeSingle & other)
{
  FunctionRangeSingle tmp(other);
  swap(tmp);
  return *this;
}

void FunctionRangeSingle::swap(FunctionRangeSingle & other)
{
  std::swap(typereference_, other.typereference_);

}

FunctionRangeSingle::~FunctionRangeSingle()
{
  delete(typereference_);

}

void FunctionRangeSingle::accept(Visitor *v)
{
  v->visitFunctionRangeSingle(this);
}

FunctionRangeSingle *FunctionRangeSingle::clone() const
{
  return new FunctionRangeSingle(*this);
}



/********************   FunctionRangeMultiple    ********************/
FunctionRangeMultiple::FunctionRangeMultiple(TypeReference *p1, ListTypeReference *p2)
{
  typereference_ = p1;
  listtypereference_ = p2;

}

FunctionRangeMultiple::FunctionRangeMultiple(const FunctionRangeMultiple & other)
{
  typereference_ = other.typereference_->clone();
  listtypereference_ = other.listtypereference_->clone();

}

FunctionRangeMultiple &FunctionRangeMultiple::operator=(const FunctionRangeMultiple & other)
{
  FunctionRangeMultiple tmp(other);
  swap(tmp);
  return *this;
}

void FunctionRangeMultiple::swap(FunctionRangeMultiple & other)
{
  std::swap(typereference_, other.typereference_);
  std::swap(listtypereference_, other.listtypereference_);

}

FunctionRangeMultiple::~FunctionRangeMultiple()
{
  delete(typereference_);
  delete(listtypereference_);

}

void FunctionRangeMultiple::accept(Visitor *v)
{
  v->visitFunctionRangeMultiple(this);
}

FunctionRangeMultiple *FunctionRangeMultiple::clone() const
{
  return new FunctionRangeMultiple(*this);
}



/********************   FunctionParameter    ********************/
FunctionParameter::FunctionParameter(TypeReference *p1, Ident p2)
{
  typereference_ = p1;
  ident_ = p2;

}

FunctionParameter::FunctionParameter(const FunctionParameter & other)
{
  typereference_ = other.typereference_->clone();
  ident_ = other.ident_;

}

FunctionParameter &FunctionParameter::operator=(const FunctionParameter & other)
{
  FunctionParameter tmp(other);
  swap(tmp);
  return *this;
}

void FunctionParameter::swap(FunctionParameter & other)
{
  std::swap(typereference_, other.typereference_);
  std::swap(ident_, other.ident_);

}

FunctionParameter::~FunctionParameter()
{
  delete(typereference_);

}

void FunctionParameter::accept(Visitor *v)
{
  v->visitFunctionParameter(this);
}

FunctionParameter *FunctionParameter::clone() const
{
  return new FunctionParameter(*this);
}



/********************   FunctionRangeSingleNamed    ********************/
FunctionRangeSingleNamed::FunctionRangeSingleNamed(FuncParam *p1)
{
  funcparam_ = p1;

}

FunctionRangeSingleNamed::FunctionRangeSingleNamed(const FunctionRangeSingleNamed & other)
{
  funcparam_ = other.funcparam_->clone();

}

FunctionRangeSingleNamed &FunctionRangeSingleNamed::operator=(const FunctionRangeSingleNamed & other)
{
  FunctionRangeSingleNamed tmp(other);
  swap(tmp);
  return *this;
}

void FunctionRangeSingleNamed::swap(FunctionRangeSingleNamed & other)
{
  std::swap(funcparam_, other.funcparam_);

}

FunctionRangeSingleNamed::~FunctionRangeSingleNamed()
{
  delete(funcparam_);

}

void FunctionRangeSingleNamed::accept(Visitor *v)
{
  v->visitFunctionRangeSingleNamed(this);
}

FunctionRangeSingleNamed *FunctionRangeSingleNamed::clone() const
{
  return new FunctionRangeSingleNamed(*this);
}



/********************   FunctionRangeMultipleNamed    ********************/
FunctionRangeMultipleNamed::FunctionRangeMultipleNamed(ListFuncParam *p1)
{
  listfuncparam_ = p1;

}

FunctionRangeMultipleNamed::FunctionRangeMultipleNamed(const FunctionRangeMultipleNamed & other)
{
  listfuncparam_ = other.listfuncparam_->clone();

}

FunctionRangeMultipleNamed &FunctionRangeMultipleNamed::operator=(const FunctionRangeMultipleNamed & other)
{
  FunctionRangeMultipleNamed tmp(other);
  swap(tmp);
  return *this;
}

void FunctionRangeMultipleNamed::swap(FunctionRangeMultipleNamed & other)
{
  std::swap(listfuncparam_, other.listfuncparam_);

}

FunctionRangeMultipleNamed::~FunctionRangeMultipleNamed()
{
  delete(listfuncparam_);

}

void FunctionRangeMultipleNamed::accept(Visitor *v)
{
  v->visitFunctionRangeMultipleNamed(this);
}

FunctionRangeMultipleNamed *FunctionRangeMultipleNamed::clone() const
{
  return new FunctionRangeMultipleNamed(*this);
}



/********************   StatementVarDecl    ********************/
StatementVarDecl::StatementVarDecl(Ident p1, TypeReference *p2)
{
  ident_ = p1;
  typereference_ = p2;

}

StatementVarDecl::StatementVarDecl(const StatementVarDecl & other)
{
  ident_ = other.ident_;
  typereference_ = other.typereference_->clone();

}

StatementVarDecl &StatementVarDecl::operator=(const StatementVarDecl & other)
{
  StatementVarDecl tmp(other);
  swap(tmp);
  return *this;
}

void StatementVarDecl::swap(StatementVarDecl & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typereference_, other.typereference_);

}

StatementVarDecl::~StatementVarDecl()
{
  delete(typereference_);

}

void StatementVarDecl::accept(Visitor *v)
{
  v->visitStatementVarDecl(this);
}

StatementVarDecl *StatementVarDecl::clone() const
{
  return new StatementVarDecl(*this);
}



/********************   StatementVarDef    ********************/
StatementVarDef::StatementVarDef(Ident p1, Value *p2)
{
  ident_ = p1;
  value_ = p2;

}

StatementVarDef::StatementVarDef(const StatementVarDef & other)
{
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

StatementVarDef &StatementVarDef::operator=(const StatementVarDef & other)
{
  StatementVarDef tmp(other);
  swap(tmp);
  return *this;
}

void StatementVarDef::swap(StatementVarDef & other)
{
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

StatementVarDef::~StatementVarDef()
{
  delete(value_);

}

void StatementVarDef::accept(Visitor *v)
{
  v->visitStatementVarDef(this);
}

StatementVarDef *StatementVarDef::clone() const
{
  return new StatementVarDef(*this);
}



/********************   StatementVarDefAsc    ********************/
StatementVarDefAsc::StatementVarDefAsc(Ident p1, TypeReference *p2, Value *p3)
{
  ident_ = p1;
  typereference_ = p2;
  value_ = p3;

}

StatementVarDefAsc::StatementVarDefAsc(const StatementVarDefAsc & other)
{
  ident_ = other.ident_;
  typereference_ = other.typereference_->clone();
  value_ = other.value_->clone();

}

StatementVarDefAsc &StatementVarDefAsc::operator=(const StatementVarDefAsc & other)
{
  StatementVarDefAsc tmp(other);
  swap(tmp);
  return *this;
}

void StatementVarDefAsc::swap(StatementVarDefAsc & other)
{
  std::swap(ident_, other.ident_);
  std::swap(typereference_, other.typereference_);
  std::swap(value_, other.value_);

}

StatementVarDefAsc::~StatementVarDefAsc()
{
  delete(typereference_);
  delete(value_);

}

void StatementVarDefAsc::accept(Visitor *v)
{
  v->visitStatementVarDefAsc(this);
}

StatementVarDefAsc *StatementVarDefAsc::clone() const
{
  return new StatementVarDefAsc(*this);
}



/********************   StatementAssignment    ********************/
StatementAssignment::StatementAssignment(Expression *p1, Value *p2)
{
  expression_ = p1;
  value_ = p2;

}

StatementAssignment::StatementAssignment(const StatementAssignment & other)
{
  expression_ = other.expression_->clone();
  value_ = other.value_->clone();

}

StatementAssignment &StatementAssignment::operator=(const StatementAssignment & other)
{
  StatementAssignment tmp(other);
  swap(tmp);
  return *this;
}

void StatementAssignment::swap(StatementAssignment & other)
{
  std::swap(expression_, other.expression_);
  std::swap(value_, other.value_);

}

StatementAssignment::~StatementAssignment()
{
  delete(expression_);
  delete(value_);

}

void StatementAssignment::accept(Visitor *v)
{
  v->visitStatementAssignment(this);
}

StatementAssignment *StatementAssignment::clone() const
{
  return new StatementAssignment(*this);
}



/********************   StatementIf    ********************/
StatementIf::StatementIf(StatementIf_ *p1)
{
  statementif__ = p1;

}

StatementIf::StatementIf(const StatementIf & other)
{
  statementif__ = other.statementif__->clone();

}

StatementIf &StatementIf::operator=(const StatementIf & other)
{
  StatementIf tmp(other);
  swap(tmp);
  return *this;
}

void StatementIf::swap(StatementIf & other)
{
  std::swap(statementif__, other.statementif__);

}

StatementIf::~StatementIf()
{
  delete(statementif__);

}

void StatementIf::accept(Visitor *v)
{
  v->visitStatementIf(this);
}

StatementIf *StatementIf::clone() const
{
  return new StatementIf(*this);
}



/********************   StatementWhile    ********************/
StatementWhile::StatementWhile(Expression *p1, Body_ *p2)
{
  expression_ = p1;
  body__ = p2;

}

StatementWhile::StatementWhile(const StatementWhile & other)
{
  expression_ = other.expression_->clone();
  body__ = other.body__->clone();

}

StatementWhile &StatementWhile::operator=(const StatementWhile & other)
{
  StatementWhile tmp(other);
  swap(tmp);
  return *this;
}

void StatementWhile::swap(StatementWhile & other)
{
  std::swap(expression_, other.expression_);
  std::swap(body__, other.body__);

}

StatementWhile::~StatementWhile()
{
  delete(expression_);
  delete(body__);

}

void StatementWhile::accept(Visitor *v)
{
  v->visitStatementWhile(this);
}

StatementWhile *StatementWhile::clone() const
{
  return new StatementWhile(*this);
}



/********************   StatementFor    ********************/
StatementFor::StatementFor(Ident p1, RangeExpr *p2, Body_ *p3)
{
  ident_ = p1;
  rangeexpr_ = p2;
  body__ = p3;

}

StatementFor::StatementFor(const StatementFor & other)
{
  ident_ = other.ident_;
  rangeexpr_ = other.rangeexpr_->clone();
  body__ = other.body__->clone();

}

StatementFor &StatementFor::operator=(const StatementFor & other)
{
  StatementFor tmp(other);
  swap(tmp);
  return *this;
}

void StatementFor::swap(StatementFor & other)
{
  std::swap(ident_, other.ident_);
  std::swap(rangeexpr_, other.rangeexpr_);
  std::swap(body__, other.body__);

}

StatementFor::~StatementFor()
{
  delete(rangeexpr_);
  delete(body__);

}

void StatementFor::accept(Visitor *v)
{
  v->visitStatementFor(this);
}

StatementFor *StatementFor::clone() const
{
  return new StatementFor(*this);
}



/********************   StatementReturnNone    ********************/
StatementReturnNone::StatementReturnNone()
{

}

StatementReturnNone::StatementReturnNone(const StatementReturnNone & other)
{

}

StatementReturnNone &StatementReturnNone::operator=(const StatementReturnNone & other)
{
  StatementReturnNone tmp(other);
  swap(tmp);
  return *this;
}

void StatementReturnNone::swap(StatementReturnNone & other)
{

}

StatementReturnNone::~StatementReturnNone()
{

}

void StatementReturnNone::accept(Visitor *v)
{
  v->visitStatementReturnNone(this);
}

StatementReturnNone *StatementReturnNone::clone() const
{
  return new StatementReturnNone(*this);
}



/********************   StatementReturnValue    ********************/
StatementReturnValue::StatementReturnValue(Expression *p1)
{
  expression_ = p1;

}

StatementReturnValue::StatementReturnValue(const StatementReturnValue & other)
{
  expression_ = other.expression_->clone();

}

StatementReturnValue &StatementReturnValue::operator=(const StatementReturnValue & other)
{
  StatementReturnValue tmp(other);
  swap(tmp);
  return *this;
}

void StatementReturnValue::swap(StatementReturnValue & other)
{
  std::swap(expression_, other.expression_);

}

StatementReturnValue::~StatementReturnValue()
{
  delete(expression_);

}

void StatementReturnValue::accept(Visitor *v)
{
  v->visitStatementReturnValue(this);
}

StatementReturnValue *StatementReturnValue::clone() const
{
  return new StatementReturnValue(*this);
}



/********************   StatementFunctionCall    ********************/
StatementFunctionCall::StatementFunctionCall(FuncCall *p1)
{
  funccall_ = p1;

}

StatementFunctionCall::StatementFunctionCall(const StatementFunctionCall & other)
{
  funccall_ = other.funccall_->clone();

}

StatementFunctionCall &StatementFunctionCall::operator=(const StatementFunctionCall & other)
{
  StatementFunctionCall tmp(other);
  swap(tmp);
  return *this;
}

void StatementFunctionCall::swap(StatementFunctionCall & other)
{
  std::swap(funccall_, other.funccall_);

}

StatementFunctionCall::~StatementFunctionCall()
{
  delete(funccall_);

}

void StatementFunctionCall::accept(Visitor *v)
{
  v->visitStatementFunctionCall(this);
}

StatementFunctionCall *StatementFunctionCall::clone() const
{
  return new StatementFunctionCall(*this);
}



/********************   IfStatement    ********************/
IfStatement::IfStatement(Expression *p1, Body_ *p2)
{
  expression_ = p1;
  body__ = p2;

}

IfStatement::IfStatement(const IfStatement & other)
{
  expression_ = other.expression_->clone();
  body__ = other.body__->clone();

}

IfStatement &IfStatement::operator=(const IfStatement & other)
{
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfStatement::swap(IfStatement & other)
{
  std::swap(expression_, other.expression_);
  std::swap(body__, other.body__);

}

IfStatement::~IfStatement()
{
  delete(expression_);
  delete(body__);

}

void IfStatement::accept(Visitor *v)
{
  v->visitIfStatement(this);
}

IfStatement *IfStatement::clone() const
{
  return new IfStatement(*this);
}



/********************   IfElseIfStatement    ********************/
IfElseIfStatement::IfElseIfStatement(Expression *p1, Body_ *p2, StatementIf_ *p3)
{
  expression_ = p1;
  body__ = p2;
  statementif__ = p3;

}

IfElseIfStatement::IfElseIfStatement(const IfElseIfStatement & other)
{
  expression_ = other.expression_->clone();
  body__ = other.body__->clone();
  statementif__ = other.statementif__->clone();

}

IfElseIfStatement &IfElseIfStatement::operator=(const IfElseIfStatement & other)
{
  IfElseIfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfElseIfStatement::swap(IfElseIfStatement & other)
{
  std::swap(expression_, other.expression_);
  std::swap(body__, other.body__);
  std::swap(statementif__, other.statementif__);

}

IfElseIfStatement::~IfElseIfStatement()
{
  delete(expression_);
  delete(body__);
  delete(statementif__);

}

void IfElseIfStatement::accept(Visitor *v)
{
  v->visitIfElseIfStatement(this);
}

IfElseIfStatement *IfElseIfStatement::clone() const
{
  return new IfElseIfStatement(*this);
}



/********************   IfElseStatement    ********************/
IfElseStatement::IfElseStatement(Expression *p1, Body_ *p2, Body_ *p3)
{
  expression_ = p1;
  body__1 = p2;
  body__2 = p3;

}

IfElseStatement::IfElseStatement(const IfElseStatement & other)
{
  expression_ = other.expression_->clone();
  body__1 = other.body__1->clone();
  body__2 = other.body__2->clone();

}

IfElseStatement &IfElseStatement::operator=(const IfElseStatement & other)
{
  IfElseStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfElseStatement::swap(IfElseStatement & other)
{
  std::swap(expression_, other.expression_);
  std::swap(body__1, other.body__1);
  std::swap(body__2, other.body__2);

}

IfElseStatement::~IfElseStatement()
{
  delete(expression_);
  delete(body__1);
  delete(body__2);

}

void IfElseStatement::accept(Visitor *v)
{
  v->visitIfElseStatement(this);
}

IfElseStatement *IfElseStatement::clone() const
{
  return new IfElseStatement(*this);
}



/********************   Body    ********************/
Body::Body(ListStatement *p1)
{
  liststatement_ = p1;

}

Body::Body(const Body & other)
{
  liststatement_ = other.liststatement_->clone();

}

Body &Body::operator=(const Body & other)
{
  Body tmp(other);
  swap(tmp);
  return *this;
}

void Body::swap(Body & other)
{
  std::swap(liststatement_, other.liststatement_);

}

Body::~Body()
{
  delete(liststatement_);

}

void Body::accept(Visitor *v)
{
  v->visitBody(this);
}

Body *Body::clone() const
{
  return new Body(*this);
}



/********************   ValueArrowed    ********************/
ValueArrowed::ValueArrowed(Expression *p1)
{
  expression_ = p1;

}

ValueArrowed::ValueArrowed(const ValueArrowed & other)
{
  expression_ = other.expression_->clone();

}

ValueArrowed &ValueArrowed::operator=(const ValueArrowed & other)
{
  ValueArrowed tmp(other);
  swap(tmp);
  return *this;
}

void ValueArrowed::swap(ValueArrowed & other)
{
  std::swap(expression_, other.expression_);

}

ValueArrowed::~ValueArrowed()
{
  delete(expression_);

}

void ValueArrowed::accept(Visitor *v)
{
  v->visitValueArrowed(this);
}

ValueArrowed *ValueArrowed::clone() const
{
  return new ValueArrowed(*this);
}



/********************   ValueBraced    ********************/
ValueBraced::ValueBraced(Expression *p1)
{
  expression_ = p1;

}

ValueBraced::ValueBraced(const ValueBraced & other)
{
  expression_ = other.expression_->clone();

}

ValueBraced &ValueBraced::operator=(const ValueBraced & other)
{
  ValueBraced tmp(other);
  swap(tmp);
  return *this;
}

void ValueBraced::swap(ValueBraced & other)
{
  std::swap(expression_, other.expression_);

}

ValueBraced::~ValueBraced()
{
  delete(expression_);

}

void ValueBraced::accept(Visitor *v)
{
  v->visitValueBraced(this);
}

ValueBraced *ValueBraced::clone() const
{
  return new ValueBraced(*this);
}



/********************   MethodReference    ********************/
MethodReference::MethodReference(Expression *p1, Ident p2)
{
  expression_ = p1;
  ident_ = p2;

}

MethodReference::MethodReference(const MethodReference & other)
{
  expression_ = other.expression_->clone();
  ident_ = other.ident_;

}

MethodReference &MethodReference::operator=(const MethodReference & other)
{
  MethodReference tmp(other);
  swap(tmp);
  return *this;
}

void MethodReference::swap(MethodReference & other)
{
  std::swap(expression_, other.expression_);
  std::swap(ident_, other.ident_);

}

MethodReference::~MethodReference()
{
  delete(expression_);

}

void MethodReference::accept(Visitor *v)
{
  v->visitMethodReference(this);
}

MethodReference *MethodReference::clone() const
{
  return new MethodReference(*this);
}



/********************   RelationalEquals    ********************/
RelationalEquals::RelationalEquals(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalEquals::RelationalEquals(const RelationalEquals & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalEquals &RelationalEquals::operator=(const RelationalEquals & other)
{
  RelationalEquals tmp(other);
  swap(tmp);
  return *this;
}

void RelationalEquals::swap(RelationalEquals & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalEquals::~RelationalEquals()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalEquals::accept(Visitor *v)
{
  v->visitRelationalEquals(this);
}

RelationalEquals *RelationalEquals::clone() const
{
  return new RelationalEquals(*this);
}



/********************   RelationalNotEquals    ********************/
RelationalNotEquals::RelationalNotEquals(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalNotEquals::RelationalNotEquals(const RelationalNotEquals & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalNotEquals &RelationalNotEquals::operator=(const RelationalNotEquals & other)
{
  RelationalNotEquals tmp(other);
  swap(tmp);
  return *this;
}

void RelationalNotEquals::swap(RelationalNotEquals & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalNotEquals::~RelationalNotEquals()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalNotEquals::accept(Visitor *v)
{
  v->visitRelationalNotEquals(this);
}

RelationalNotEquals *RelationalNotEquals::clone() const
{
  return new RelationalNotEquals(*this);
}



/********************   RelationalLess    ********************/
RelationalLess::RelationalLess(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalLess::RelationalLess(const RelationalLess & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalLess &RelationalLess::operator=(const RelationalLess & other)
{
  RelationalLess tmp(other);
  swap(tmp);
  return *this;
}

void RelationalLess::swap(RelationalLess & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalLess::~RelationalLess()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalLess::accept(Visitor *v)
{
  v->visitRelationalLess(this);
}

RelationalLess *RelationalLess::clone() const
{
  return new RelationalLess(*this);
}



/********************   RelationalGreater    ********************/
RelationalGreater::RelationalGreater(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalGreater::RelationalGreater(const RelationalGreater & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalGreater &RelationalGreater::operator=(const RelationalGreater & other)
{
  RelationalGreater tmp(other);
  swap(tmp);
  return *this;
}

void RelationalGreater::swap(RelationalGreater & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalGreater::~RelationalGreater()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalGreater::accept(Visitor *v)
{
  v->visitRelationalGreater(this);
}

RelationalGreater *RelationalGreater::clone() const
{
  return new RelationalGreater(*this);
}



/********************   RelationalLessOrEqual    ********************/
RelationalLessOrEqual::RelationalLessOrEqual(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalLessOrEqual::RelationalLessOrEqual(const RelationalLessOrEqual & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalLessOrEqual &RelationalLessOrEqual::operator=(const RelationalLessOrEqual & other)
{
  RelationalLessOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void RelationalLessOrEqual::swap(RelationalLessOrEqual & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalLessOrEqual::~RelationalLessOrEqual()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalLessOrEqual::accept(Visitor *v)
{
  v->visitRelationalLessOrEqual(this);
}

RelationalLessOrEqual *RelationalLessOrEqual::clone() const
{
  return new RelationalLessOrEqual(*this);
}



/********************   RelationalGreaterOrEqual    ********************/
RelationalGreaterOrEqual::RelationalGreaterOrEqual(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

RelationalGreaterOrEqual::RelationalGreaterOrEqual(const RelationalGreaterOrEqual & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

RelationalGreaterOrEqual &RelationalGreaterOrEqual::operator=(const RelationalGreaterOrEqual & other)
{
  RelationalGreaterOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void RelationalGreaterOrEqual::swap(RelationalGreaterOrEqual & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

RelationalGreaterOrEqual::~RelationalGreaterOrEqual()
{
  delete(expression_1);
  delete(expression_2);

}

void RelationalGreaterOrEqual::accept(Visitor *v)
{
  v->visitRelationalGreaterOrEqual(this);
}

RelationalGreaterOrEqual *RelationalGreaterOrEqual::clone() const
{
  return new RelationalGreaterOrEqual(*this);
}



/********************   ArithmeticSum    ********************/
ArithmeticSum::ArithmeticSum(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticSum::ArithmeticSum(const ArithmeticSum & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticSum &ArithmeticSum::operator=(const ArithmeticSum & other)
{
  ArithmeticSum tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticSum::swap(ArithmeticSum & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticSum::~ArithmeticSum()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticSum::accept(Visitor *v)
{
  v->visitArithmeticSum(this);
}

ArithmeticSum *ArithmeticSum::clone() const
{
  return new ArithmeticSum(*this);
}



/********************   ArithmeticDifference    ********************/
ArithmeticDifference::ArithmeticDifference(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticDifference::ArithmeticDifference(const ArithmeticDifference & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticDifference &ArithmeticDifference::operator=(const ArithmeticDifference & other)
{
  ArithmeticDifference tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticDifference::swap(ArithmeticDifference & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticDifference::~ArithmeticDifference()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticDifference::accept(Visitor *v)
{
  v->visitArithmeticDifference(this);
}

ArithmeticDifference *ArithmeticDifference::clone() const
{
  return new ArithmeticDifference(*this);
}



/********************   ArithmeticProduct    ********************/
ArithmeticProduct::ArithmeticProduct(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticProduct::ArithmeticProduct(const ArithmeticProduct & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticProduct &ArithmeticProduct::operator=(const ArithmeticProduct & other)
{
  ArithmeticProduct tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticProduct::swap(ArithmeticProduct & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticProduct::~ArithmeticProduct()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticProduct::accept(Visitor *v)
{
  v->visitArithmeticProduct(this);
}

ArithmeticProduct *ArithmeticProduct::clone() const
{
  return new ArithmeticProduct(*this);
}



/********************   ArithmeticQuotient    ********************/
ArithmeticQuotient::ArithmeticQuotient(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticQuotient::ArithmeticQuotient(const ArithmeticQuotient & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticQuotient &ArithmeticQuotient::operator=(const ArithmeticQuotient & other)
{
  ArithmeticQuotient tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticQuotient::swap(ArithmeticQuotient & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticQuotient::~ArithmeticQuotient()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticQuotient::accept(Visitor *v)
{
  v->visitArithmeticQuotient(this);
}

ArithmeticQuotient *ArithmeticQuotient::clone() const
{
  return new ArithmeticQuotient(*this);
}



/********************   ArithmeticModulus    ********************/
ArithmeticModulus::ArithmeticModulus(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticModulus::ArithmeticModulus(const ArithmeticModulus & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticModulus &ArithmeticModulus::operator=(const ArithmeticModulus & other)
{
  ArithmeticModulus tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticModulus::swap(ArithmeticModulus & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticModulus::~ArithmeticModulus()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticModulus::accept(Visitor *v)
{
  v->visitArithmeticModulus(this);
}

ArithmeticModulus *ArithmeticModulus::clone() const
{
  return new ArithmeticModulus(*this);
}



/********************   ArithmeticExponentiation    ********************/
ArithmeticExponentiation::ArithmeticExponentiation(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArithmeticExponentiation::ArithmeticExponentiation(const ArithmeticExponentiation & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArithmeticExponentiation &ArithmeticExponentiation::operator=(const ArithmeticExponentiation & other)
{
  ArithmeticExponentiation tmp(other);
  swap(tmp);
  return *this;
}

void ArithmeticExponentiation::swap(ArithmeticExponentiation & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArithmeticExponentiation::~ArithmeticExponentiation()
{
  delete(expression_1);
  delete(expression_2);

}

void ArithmeticExponentiation::accept(Visitor *v)
{
  v->visitArithmeticExponentiation(this);
}

ArithmeticExponentiation *ArithmeticExponentiation::clone() const
{
  return new ArithmeticExponentiation(*this);
}



/********************   LogicalUnaryNot    ********************/
LogicalUnaryNot::LogicalUnaryNot(Expression *p1)
{
  expression_ = p1;

}

LogicalUnaryNot::LogicalUnaryNot(const LogicalUnaryNot & other)
{
  expression_ = other.expression_->clone();

}

LogicalUnaryNot &LogicalUnaryNot::operator=(const LogicalUnaryNot & other)
{
  LogicalUnaryNot tmp(other);
  swap(tmp);
  return *this;
}

void LogicalUnaryNot::swap(LogicalUnaryNot & other)
{
  std::swap(expression_, other.expression_);

}

LogicalUnaryNot::~LogicalUnaryNot()
{
  delete(expression_);

}

void LogicalUnaryNot::accept(Visitor *v)
{
  v->visitLogicalUnaryNot(this);
}

LogicalUnaryNot *LogicalUnaryNot::clone() const
{
  return new LogicalUnaryNot(*this);
}



/********************   LogicalConjunction    ********************/
LogicalConjunction::LogicalConjunction(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LogicalConjunction::LogicalConjunction(const LogicalConjunction & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LogicalConjunction &LogicalConjunction::operator=(const LogicalConjunction & other)
{
  LogicalConjunction tmp(other);
  swap(tmp);
  return *this;
}

void LogicalConjunction::swap(LogicalConjunction & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LogicalConjunction::~LogicalConjunction()
{
  delete(expression_1);
  delete(expression_2);

}

void LogicalConjunction::accept(Visitor *v)
{
  v->visitLogicalConjunction(this);
}

LogicalConjunction *LogicalConjunction::clone() const
{
  return new LogicalConjunction(*this);
}



/********************   LogicalDisjunction    ********************/
LogicalDisjunction::LogicalDisjunction(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LogicalDisjunction::LogicalDisjunction(const LogicalDisjunction & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LogicalDisjunction &LogicalDisjunction::operator=(const LogicalDisjunction & other)
{
  LogicalDisjunction tmp(other);
  swap(tmp);
  return *this;
}

void LogicalDisjunction::swap(LogicalDisjunction & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LogicalDisjunction::~LogicalDisjunction()
{
  delete(expression_1);
  delete(expression_2);

}

void LogicalDisjunction::accept(Visitor *v)
{
  v->visitLogicalDisjunction(this);
}

LogicalDisjunction *LogicalDisjunction::clone() const
{
  return new LogicalDisjunction(*this);
}



/********************   LogicalExclusiveDisjunction    ********************/
LogicalExclusiveDisjunction::LogicalExclusiveDisjunction(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LogicalExclusiveDisjunction::LogicalExclusiveDisjunction(const LogicalExclusiveDisjunction & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LogicalExclusiveDisjunction &LogicalExclusiveDisjunction::operator=(const LogicalExclusiveDisjunction & other)
{
  LogicalExclusiveDisjunction tmp(other);
  swap(tmp);
  return *this;
}

void LogicalExclusiveDisjunction::swap(LogicalExclusiveDisjunction & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LogicalExclusiveDisjunction::~LogicalExclusiveDisjunction()
{
  delete(expression_1);
  delete(expression_2);

}

void LogicalExclusiveDisjunction::accept(Visitor *v)
{
  v->visitLogicalExclusiveDisjunction(this);
}

LogicalExclusiveDisjunction *LogicalExclusiveDisjunction::clone() const
{
  return new LogicalExclusiveDisjunction(*this);
}



/********************   LogicalImplication    ********************/
LogicalImplication::LogicalImplication(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LogicalImplication::LogicalImplication(const LogicalImplication & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LogicalImplication &LogicalImplication::operator=(const LogicalImplication & other)
{
  LogicalImplication tmp(other);
  swap(tmp);
  return *this;
}

void LogicalImplication::swap(LogicalImplication & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LogicalImplication::~LogicalImplication()
{
  delete(expression_1);
  delete(expression_2);

}

void LogicalImplication::accept(Visitor *v)
{
  v->visitLogicalImplication(this);
}

LogicalImplication *LogicalImplication::clone() const
{
  return new LogicalImplication(*this);
}



/********************   LogicalEquivalence    ********************/
LogicalEquivalence::LogicalEquivalence(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

LogicalEquivalence::LogicalEquivalence(const LogicalEquivalence & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

LogicalEquivalence &LogicalEquivalence::operator=(const LogicalEquivalence & other)
{
  LogicalEquivalence tmp(other);
  swap(tmp);
  return *this;
}

void LogicalEquivalence::swap(LogicalEquivalence & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

LogicalEquivalence::~LogicalEquivalence()
{
  delete(expression_1);
  delete(expression_2);

}

void LogicalEquivalence::accept(Visitor *v)
{
  v->visitLogicalEquivalence(this);
}

LogicalEquivalence *LogicalEquivalence::clone() const
{
  return new LogicalEquivalence(*this);
}



/********************   UnaryHashCode    ********************/
UnaryHashCode::UnaryHashCode(Expression *p1)
{
  expression_ = p1;

}

UnaryHashCode::UnaryHashCode(const UnaryHashCode & other)
{
  expression_ = other.expression_->clone();

}

UnaryHashCode &UnaryHashCode::operator=(const UnaryHashCode & other)
{
  UnaryHashCode tmp(other);
  swap(tmp);
  return *this;
}

void UnaryHashCode::swap(UnaryHashCode & other)
{
  std::swap(expression_, other.expression_);

}

UnaryHashCode::~UnaryHashCode()
{
  delete(expression_);

}

void UnaryHashCode::accept(Visitor *v)
{
  v->visitUnaryHashCode(this);
}

UnaryHashCode *UnaryHashCode::clone() const
{
  return new UnaryHashCode(*this);
}



/********************   UnaryMinus    ********************/
UnaryMinus::UnaryMinus(Expression *p1)
{
  expression_ = p1;

}

UnaryMinus::UnaryMinus(const UnaryMinus & other)
{
  expression_ = other.expression_->clone();

}

UnaryMinus &UnaryMinus::operator=(const UnaryMinus & other)
{
  UnaryMinus tmp(other);
  swap(tmp);
  return *this;
}

void UnaryMinus::swap(UnaryMinus & other)
{
  std::swap(expression_, other.expression_);

}

UnaryMinus::~UnaryMinus()
{
  delete(expression_);

}

void UnaryMinus::accept(Visitor *v)
{
  v->visitUnaryMinus(this);
}

UnaryMinus *UnaryMinus::clone() const
{
  return new UnaryMinus(*this);
}



/********************   TrueTerm    ********************/
TrueTerm::TrueTerm()
{

}

TrueTerm::TrueTerm(const TrueTerm & other)
{

}

TrueTerm &TrueTerm::operator=(const TrueTerm & other)
{
  TrueTerm tmp(other);
  swap(tmp);
  return *this;
}

void TrueTerm::swap(TrueTerm & other)
{

}

TrueTerm::~TrueTerm()
{

}

void TrueTerm::accept(Visitor *v)
{
  v->visitTrueTerm(this);
}

TrueTerm *TrueTerm::clone() const
{
  return new TrueTerm(*this);
}



/********************   FalseTerm    ********************/
FalseTerm::FalseTerm()
{

}

FalseTerm::FalseTerm(const FalseTerm & other)
{

}

FalseTerm &FalseTerm::operator=(const FalseTerm & other)
{
  FalseTerm tmp(other);
  swap(tmp);
  return *this;
}

void FalseTerm::swap(FalseTerm & other)
{

}

FalseTerm::~FalseTerm()
{

}

void FalseTerm::accept(Visitor *v)
{
  v->visitFalseTerm(this);
}

FalseTerm *FalseTerm::clone() const
{
  return new FalseTerm(*this);
}



/********************   EmptyTerm    ********************/
EmptyTerm::EmptyTerm()
{

}

EmptyTerm::EmptyTerm(const EmptyTerm & other)
{

}

EmptyTerm &EmptyTerm::operator=(const EmptyTerm & other)
{
  EmptyTerm tmp(other);
  swap(tmp);
  return *this;
}

void EmptyTerm::swap(EmptyTerm & other)
{

}

EmptyTerm::~EmptyTerm()
{

}

void EmptyTerm::accept(Visitor *v)
{
  v->visitEmptyTerm(this);
}

EmptyTerm *EmptyTerm::clone() const
{
  return new EmptyTerm(*this);
}



/********************   StringTerm    ********************/
StringTerm::StringTerm(String p1)
{
  string_ = p1;

}

StringTerm::StringTerm(const StringTerm & other)
{
  string_ = other.string_;

}

StringTerm &StringTerm::operator=(const StringTerm & other)
{
  StringTerm tmp(other);
  swap(tmp);
  return *this;
}

void StringTerm::swap(StringTerm & other)
{
  std::swap(string_, other.string_);

}

StringTerm::~StringTerm()
{

}

void StringTerm::accept(Visitor *v)
{
  v->visitStringTerm(this);
}

StringTerm *StringTerm::clone() const
{
  return new StringTerm(*this);
}



/********************   IntegerTerm    ********************/
IntegerTerm::IntegerTerm(Integer p1)
{
  integer_ = p1;

}

IntegerTerm::IntegerTerm(const IntegerTerm & other)
{
  integer_ = other.integer_;

}

IntegerTerm &IntegerTerm::operator=(const IntegerTerm & other)
{
  IntegerTerm tmp(other);
  swap(tmp);
  return *this;
}

void IntegerTerm::swap(IntegerTerm & other)
{
  std::swap(integer_, other.integer_);

}

IntegerTerm::~IntegerTerm()
{

}

void IntegerTerm::accept(Visitor *v)
{
  v->visitIntegerTerm(this);
}

IntegerTerm *IntegerTerm::clone() const
{
  return new IntegerTerm(*this);
}



/********************   DoubleTerm    ********************/
DoubleTerm::DoubleTerm(Double p1)
{
  double_ = p1;

}

DoubleTerm::DoubleTerm(const DoubleTerm & other)
{
  double_ = other.double_;

}

DoubleTerm &DoubleTerm::operator=(const DoubleTerm & other)
{
  DoubleTerm tmp(other);
  swap(tmp);
  return *this;
}

void DoubleTerm::swap(DoubleTerm & other)
{
  std::swap(double_, other.double_);

}

DoubleTerm::~DoubleTerm()
{

}

void DoubleTerm::accept(Visitor *v)
{
  v->visitDoubleTerm(this);
}

DoubleTerm *DoubleTerm::clone() const
{
  return new DoubleTerm(*this);
}



/********************   VariableReferenceTerm    ********************/
VariableReferenceTerm::VariableReferenceTerm(Ident p1)
{
  ident_ = p1;

}

VariableReferenceTerm::VariableReferenceTerm(const VariableReferenceTerm & other)
{
  ident_ = other.ident_;

}

VariableReferenceTerm &VariableReferenceTerm::operator=(const VariableReferenceTerm & other)
{
  VariableReferenceTerm tmp(other);
  swap(tmp);
  return *this;
}

void VariableReferenceTerm::swap(VariableReferenceTerm & other)
{
  std::swap(ident_, other.ident_);

}

VariableReferenceTerm::~VariableReferenceTerm()
{

}

void VariableReferenceTerm::accept(Visitor *v)
{
  v->visitVariableReferenceTerm(this);
}

VariableReferenceTerm *VariableReferenceTerm::clone() const
{
  return new VariableReferenceTerm(*this);
}



/********************   ArrayReferenceTerm    ********************/
ArrayReferenceTerm::ArrayReferenceTerm(Expression *p1, Expression *p2)
{
  expression_1 = p1;
  expression_2 = p2;

}

ArrayReferenceTerm::ArrayReferenceTerm(const ArrayReferenceTerm & other)
{
  expression_1 = other.expression_1->clone();
  expression_2 = other.expression_2->clone();

}

ArrayReferenceTerm &ArrayReferenceTerm::operator=(const ArrayReferenceTerm & other)
{
  ArrayReferenceTerm tmp(other);
  swap(tmp);
  return *this;
}

void ArrayReferenceTerm::swap(ArrayReferenceTerm & other)
{
  std::swap(expression_1, other.expression_1);
  std::swap(expression_2, other.expression_2);

}

ArrayReferenceTerm::~ArrayReferenceTerm()
{
  delete(expression_1);
  delete(expression_2);

}

void ArrayReferenceTerm::accept(Visitor *v)
{
  v->visitArrayReferenceTerm(this);
}

ArrayReferenceTerm *ArrayReferenceTerm::clone() const
{
  return new ArrayReferenceTerm(*this);
}



/********************   FieldReferenceTerm    ********************/
FieldReferenceTerm::FieldReferenceTerm(Expression *p1, Ident p2)
{
  expression_ = p1;
  ident_ = p2;

}

FieldReferenceTerm::FieldReferenceTerm(const FieldReferenceTerm & other)
{
  expression_ = other.expression_->clone();
  ident_ = other.ident_;

}

FieldReferenceTerm &FieldReferenceTerm::operator=(const FieldReferenceTerm & other)
{
  FieldReferenceTerm tmp(other);
  swap(tmp);
  return *this;
}

void FieldReferenceTerm::swap(FieldReferenceTerm & other)
{
  std::swap(expression_, other.expression_);
  std::swap(ident_, other.ident_);

}

FieldReferenceTerm::~FieldReferenceTerm()
{
  delete(expression_);

}

void FieldReferenceTerm::accept(Visitor *v)
{
  v->visitFieldReferenceTerm(this);
}

FieldReferenceTerm *FieldReferenceTerm::clone() const
{
  return new FieldReferenceTerm(*this);
}



/********************   FunctionCallExpr    ********************/
FunctionCallExpr::FunctionCallExpr(FuncCall *p1)
{
  funccall_ = p1;

}

FunctionCallExpr::FunctionCallExpr(const FunctionCallExpr & other)
{
  funccall_ = other.funccall_->clone();

}

FunctionCallExpr &FunctionCallExpr::operator=(const FunctionCallExpr & other)
{
  FunctionCallExpr tmp(other);
  swap(tmp);
  return *this;
}

void FunctionCallExpr::swap(FunctionCallExpr & other)
{
  std::swap(funccall_, other.funccall_);

}

FunctionCallExpr::~FunctionCallExpr()
{
  delete(funccall_);

}

void FunctionCallExpr::accept(Visitor *v)
{
  v->visitFunctionCallExpr(this);
}

FunctionCallExpr *FunctionCallExpr::clone() const
{
  return new FunctionCallExpr(*this);
}



/********************   ArrayInitializer    ********************/
ArrayInitializer::ArrayInitializer(ListExpression *p1)
{
  listexpression_ = p1;

}

ArrayInitializer::ArrayInitializer(const ArrayInitializer & other)
{
  listexpression_ = other.listexpression_->clone();

}

ArrayInitializer &ArrayInitializer::operator=(const ArrayInitializer & other)
{
  ArrayInitializer tmp(other);
  swap(tmp);
  return *this;
}

void ArrayInitializer::swap(ArrayInitializer & other)
{
  std::swap(listexpression_, other.listexpression_);

}

ArrayInitializer::~ArrayInitializer()
{
  delete(listexpression_);

}

void ArrayInitializer::accept(Visitor *v)
{
  v->visitArrayInitializer(this);
}

ArrayInitializer *ArrayInitializer::clone() const
{
  return new ArrayInitializer(*this);
}



/********************   RangeExpressionTerm    ********************/
RangeExpressionTerm::RangeExpressionTerm(RangeExpr *p1)
{
  rangeexpr_ = p1;

}

RangeExpressionTerm::RangeExpressionTerm(const RangeExpressionTerm & other)
{
  rangeexpr_ = other.rangeexpr_->clone();

}

RangeExpressionTerm &RangeExpressionTerm::operator=(const RangeExpressionTerm & other)
{
  RangeExpressionTerm tmp(other);
  swap(tmp);
  return *this;
}

void RangeExpressionTerm::swap(RangeExpressionTerm & other)
{
  std::swap(rangeexpr_, other.rangeexpr_);

}

RangeExpressionTerm::~RangeExpressionTerm()
{
  delete(rangeexpr_);

}

void RangeExpressionTerm::accept(Visitor *v)
{
  v->visitRangeExpressionTerm(this);
}

RangeExpressionTerm *RangeExpressionTerm::clone() const
{
  return new RangeExpressionTerm(*this);
}



/********************   FunctionCall    ********************/
FunctionCall::FunctionCall(Expression *p1, ListExpression *p2)
{
  expression_ = p1;
  listexpression_ = p2;

}

FunctionCall::FunctionCall(const FunctionCall & other)
{
  expression_ = other.expression_->clone();
  listexpression_ = other.listexpression_->clone();

}

FunctionCall &FunctionCall::operator=(const FunctionCall & other)
{
  FunctionCall tmp(other);
  swap(tmp);
  return *this;
}

void FunctionCall::swap(FunctionCall & other)
{
  std::swap(expression_, other.expression_);
  std::swap(listexpression_, other.listexpression_);

}

FunctionCall::~FunctionCall()
{
  delete(expression_);
  delete(listexpression_);

}

void FunctionCall::accept(Visitor *v)
{
  v->visitFunctionCall(this);
}

FunctionCall *FunctionCall::clone() const
{
  return new FunctionCall(*this);
}



/********************   RangeExpression    ********************/
RangeExpression::RangeExpression(UnsteppedRangeExpression *p1)
{
  unsteppedrangeexpression_ = p1;

}

RangeExpression::RangeExpression(const RangeExpression & other)
{
  unsteppedrangeexpression_ = other.unsteppedrangeexpression_->clone();

}

RangeExpression &RangeExpression::operator=(const RangeExpression & other)
{
  RangeExpression tmp(other);
  swap(tmp);
  return *this;
}

void RangeExpression::swap(RangeExpression & other)
{
  std::swap(unsteppedrangeexpression_, other.unsteppedrangeexpression_);

}

RangeExpression::~RangeExpression()
{
  delete(unsteppedrangeexpression_);

}

void RangeExpression::accept(Visitor *v)
{
  v->visitRangeExpression(this);
}

RangeExpression *RangeExpression::clone() const
{
  return new RangeExpression(*this);
}



/********************   SteppedRangeExpression    ********************/
SteppedRangeExpression::SteppedRangeExpression(UnsteppedRangeExpression *p1, Integer p2)
{
  unsteppedrangeexpression_ = p1;
  integer_ = p2;

}

SteppedRangeExpression::SteppedRangeExpression(const SteppedRangeExpression & other)
{
  unsteppedrangeexpression_ = other.unsteppedrangeexpression_->clone();
  integer_ = other.integer_;

}

SteppedRangeExpression &SteppedRangeExpression::operator=(const SteppedRangeExpression & other)
{
  SteppedRangeExpression tmp(other);
  swap(tmp);
  return *this;
}

void SteppedRangeExpression::swap(SteppedRangeExpression & other)
{
  std::swap(unsteppedrangeexpression_, other.unsteppedrangeexpression_);
  std::swap(integer_, other.integer_);

}

SteppedRangeExpression::~SteppedRangeExpression()
{
  delete(unsteppedrangeexpression_);

}

void SteppedRangeExpression::accept(Visitor *v)
{
  v->visitSteppedRangeExpression(this);
}

SteppedRangeExpression *SteppedRangeExpression::clone() const
{
  return new SteppedRangeExpression(*this);
}



/********************   OpenRange    ********************/
OpenRange::OpenRange(RangeBody_ *p1)
{
  rangebody__ = p1;

}

OpenRange::OpenRange(const OpenRange & other)
{
  rangebody__ = other.rangebody__->clone();

}

OpenRange &OpenRange::operator=(const OpenRange & other)
{
  OpenRange tmp(other);
  swap(tmp);
  return *this;
}

void OpenRange::swap(OpenRange & other)
{
  std::swap(rangebody__, other.rangebody__);

}

OpenRange::~OpenRange()
{
  delete(rangebody__);

}

void OpenRange::accept(Visitor *v)
{
  v->visitOpenRange(this);
}

OpenRange *OpenRange::clone() const
{
  return new OpenRange(*this);
}



/********************   ClosedRange    ********************/
ClosedRange::ClosedRange(RangeBody_ *p1)
{
  rangebody__ = p1;

}

ClosedRange::ClosedRange(const ClosedRange & other)
{
  rangebody__ = other.rangebody__->clone();

}

ClosedRange &ClosedRange::operator=(const ClosedRange & other)
{
  ClosedRange tmp(other);
  swap(tmp);
  return *this;
}

void ClosedRange::swap(ClosedRange & other)
{
  std::swap(rangebody__, other.rangebody__);

}

ClosedRange::~ClosedRange()
{
  delete(rangebody__);

}

void ClosedRange::accept(Visitor *v)
{
  v->visitClosedRange(this);
}

ClosedRange *ClosedRange::clone() const
{
  return new ClosedRange(*this);
}



/********************   LeftClosedRightOpenedRange    ********************/
LeftClosedRightOpenedRange::LeftClosedRightOpenedRange(RangeBody_ *p1)
{
  rangebody__ = p1;

}

LeftClosedRightOpenedRange::LeftClosedRightOpenedRange(const LeftClosedRightOpenedRange & other)
{
  rangebody__ = other.rangebody__->clone();

}

LeftClosedRightOpenedRange &LeftClosedRightOpenedRange::operator=(const LeftClosedRightOpenedRange & other)
{
  LeftClosedRightOpenedRange tmp(other);
  swap(tmp);
  return *this;
}

void LeftClosedRightOpenedRange::swap(LeftClosedRightOpenedRange & other)
{
  std::swap(rangebody__, other.rangebody__);

}

LeftClosedRightOpenedRange::~LeftClosedRightOpenedRange()
{
  delete(rangebody__);

}

void LeftClosedRightOpenedRange::accept(Visitor *v)
{
  v->visitLeftClosedRightOpenedRange(this);
}

LeftClosedRightOpenedRange *LeftClosedRightOpenedRange::clone() const
{
  return new LeftClosedRightOpenedRange(*this);
}



/********************   LeftOpenedRightClosedRange    ********************/
LeftOpenedRightClosedRange::LeftOpenedRightClosedRange(RangeBody_ *p1)
{
  rangebody__ = p1;

}

LeftOpenedRightClosedRange::LeftOpenedRightClosedRange(const LeftOpenedRightClosedRange & other)
{
  rangebody__ = other.rangebody__->clone();

}

LeftOpenedRightClosedRange &LeftOpenedRightClosedRange::operator=(const LeftOpenedRightClosedRange & other)
{
  LeftOpenedRightClosedRange tmp(other);
  swap(tmp);
  return *this;
}

void LeftOpenedRightClosedRange::swap(LeftOpenedRightClosedRange & other)
{
  std::swap(rangebody__, other.rangebody__);

}

LeftOpenedRightClosedRange::~LeftOpenedRightClosedRange()
{
  delete(rangebody__);

}

void LeftOpenedRightClosedRange::accept(Visitor *v)
{
  v->visitLeftOpenedRightClosedRange(this);
}

LeftOpenedRightClosedRange *LeftOpenedRightClosedRange::clone() const
{
  return new LeftOpenedRightClosedRange(*this);
}



/********************   RangeBody    ********************/
RangeBody::RangeBody(Integer p1, Integer p2)
{
  integer_1 = p1;
  integer_2 = p2;

}

RangeBody::RangeBody(const RangeBody & other)
{
  integer_1 = other.integer_1;
  integer_2 = other.integer_2;

}

RangeBody &RangeBody::operator=(const RangeBody & other)
{
  RangeBody tmp(other);
  swap(tmp);
  return *this;
}

void RangeBody::swap(RangeBody & other)
{
  std::swap(integer_1, other.integer_1);
  std::swap(integer_2, other.integer_2);

}

RangeBody::~RangeBody()
{

}

void RangeBody::accept(Visitor *v)
{
  v->visitRangeBody(this);
}

RangeBody *RangeBody::clone() const
{
  return new RangeBody(*this);
}




/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}

ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}

ListDecl* consListDecl(Decl* x, ListDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}

ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}

ListIdent* consListIdent(Ident x, ListIdent* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFieldDef    ********************/

void ListFieldDef::accept(Visitor *v)
{
  v->visitListFieldDef(this);
}

ListFieldDef *ListFieldDef::clone() const
{
  return new ListFieldDef(*this);
}

ListFieldDef* consListFieldDef(FieldDef* x, ListFieldDef* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListTypeReference    ********************/

void ListTypeReference::accept(Visitor *v)
{
  v->visitListTypeReference(this);
}

ListTypeReference *ListTypeReference::clone() const
{
  return new ListTypeReference(*this);
}

ListTypeReference* consListTypeReference(TypeReference* x, ListTypeReference* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFuncParam    ********************/

void ListFuncParam::accept(Visitor *v)
{
  v->visitListFuncParam(this);
}

ListFuncParam *ListFuncParam::clone() const
{
  return new ListFuncParam(*this);
}

ListFuncParam* consListFuncParam(FuncParam* x, ListFuncParam* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}

ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}

ListStatement* consListStatement(Statement* x, ListStatement* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpression    ********************/

void ListExpression::accept(Visitor *v)
{
  v->visitListExpression(this);
}

ListExpression *ListExpression::clone() const
{
  return new ListExpression(*this);
}

ListExpression* consListExpression(Expression* x, ListExpression* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





