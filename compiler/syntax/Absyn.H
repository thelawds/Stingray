/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program_;
class Decl;
class TypeReference;
class ClassDecl;
class Extends;
class FieldDef;
class Statics;
class CBody;
class FuncDecl;
class FuncDefn;
class FuncDomain;
class FuncRange;
class FuncParam;
class FuncRangeNamed;
class Statement;
class StatementIf_;
class Body_;
class Value;
class Expression;
class FuncCall;
class RangeExpr;
class UnsteppedRangeExpression;
class RangeBody_;
class Program;
class Declaration;
class NothingType;
class BoolType;
class IntegerType;
class DoubleType;
class StringType;
class AutoType;
class FunctionDeclType;
class FunctionDefType;
class ArrayType;
class ClassType;
class UserType;
class ClassDeclaration;
class ExtendsEmpty;
class ExtendsList;
class FieldDeclaration;
class FieldDefinition;
class FieldDefinitionAsc;
class StaticsEmpty;
class StaticsBody;
class ClassBody;
class FunctionDeclaration;
class FunctionDefinition;
class FunctionDomain;
class FunctionRangeSingle;
class FunctionRangeMultiple;
class FunctionParameter;
class FunctionRangeSingleNamed;
class FunctionRangeMultipleNamed;
class StatementVarDecl;
class StatementVarDef;
class StatementVarDefAsc;
class StatementAssignment;
class StatementIf;
class StatementWhile;
class StatementFor;
class StatementReturnNone;
class StatementReturnValue;
class StatementFunctionCall;
class IfStatement;
class IfElseIfStatement;
class IfElseStatement;
class Body;
class ValueArrowed;
class ValueBraced;
class MethodReference;
class RelationalEquals;
class RelationalNotEquals;
class RelationalLess;
class RelationalGreater;
class RelationalLessOrEqual;
class RelationalGreaterOrEqual;
class ArithmeticSum;
class ArithmeticDifference;
class ArithmeticProduct;
class ArithmeticQuotient;
class ArithmeticModulus;
class ArithmeticExponentiation;
class LogicalUnaryNot;
class LogicalConjunction;
class LogicalDisjunction;
class LogicalExclusiveDisjunction;
class LogicalImplication;
class LogicalEquivalence;
class UnaryHashCode;
class UnaryMinus;
class TrueTerm;
class FalseTerm;
class EmptyTerm;
class StringTerm;
class IntegerTerm;
class DoubleTerm;
class VariableReferenceTerm;
class ArrayReferenceTerm;
class FieldReferenceTerm;
class FunctionCallExpr;
class FunctionCall;
class ArrayInitializer;
class RangeExpressionTerm;
class RangeExpression;
class SteppedRangeExpression;
class OpenRange;
class ClosedRange;
class LeftClosedRightOpenedRange;
class LeftOpenedRightClosedRange;
class RangeBody;
class ListDecl;
class ListIdent;
class ListFieldDef;
class ListTypeReference;
class ListFuncParam;
class ListStatement;
class ListExpression;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram_(Program_ *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitTypeReference(TypeReference *p) = 0;
  virtual void visitClassDecl(ClassDecl *p) = 0;
  virtual void visitExtends(Extends *p) = 0;
  virtual void visitFieldDef(FieldDef *p) = 0;
  virtual void visitStatics(Statics *p) = 0;
  virtual void visitCBody(CBody *p) = 0;
  virtual void visitFuncDecl(FuncDecl *p) = 0;
  virtual void visitFuncDefn(FuncDefn *p) = 0;
  virtual void visitFuncDomain(FuncDomain *p) = 0;
  virtual void visitFuncRange(FuncRange *p) = 0;
  virtual void visitFuncParam(FuncParam *p) = 0;
  virtual void visitFuncRangeNamed(FuncRangeNamed *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitStatementIf_(StatementIf_ *p) = 0;
  virtual void visitBody_(Body_ *p) = 0;
  virtual void visitValue(Value *p) = 0;
  virtual void visitExpression(Expression *p) = 0;
  virtual void visitFuncCall(FuncCall *p) = 0;
  virtual void visitRangeExpr(RangeExpr *p) = 0;
  virtual void visitUnsteppedRangeExpression(UnsteppedRangeExpression *p) = 0;
  virtual void visitRangeBody_(RangeBody_ *p) = 0;
  virtual void visitProgram(Program *p) = 0;
  virtual void visitDeclaration(Declaration *p) = 0;
  virtual void visitNothingType(NothingType *p) = 0;
  virtual void visitBoolType(BoolType *p) = 0;
  virtual void visitIntegerType(IntegerType *p) = 0;
  virtual void visitDoubleType(DoubleType *p) = 0;
  virtual void visitStringType(StringType *p) = 0;
  virtual void visitAutoType(AutoType *p) = 0;
  virtual void visitFunctionDeclType(FunctionDeclType *p) = 0;
  virtual void visitFunctionDefType(FunctionDefType *p) = 0;
  virtual void visitArrayType(ArrayType *p) = 0;
  virtual void visitClassType(ClassType *p) = 0;
  virtual void visitUserType(UserType *p) = 0;
  virtual void visitClassDeclaration(ClassDeclaration *p) = 0;
  virtual void visitExtendsEmpty(ExtendsEmpty *p) = 0;
  virtual void visitExtendsList(ExtendsList *p) = 0;
  virtual void visitFieldDeclaration(FieldDeclaration *p) = 0;
  virtual void visitFieldDefinition(FieldDefinition *p) = 0;
  virtual void visitFieldDefinitionAsc(FieldDefinitionAsc *p) = 0;
  virtual void visitStaticsEmpty(StaticsEmpty *p) = 0;
  virtual void visitStaticsBody(StaticsBody *p) = 0;
  virtual void visitClassBody(ClassBody *p) = 0;
  virtual void visitFunctionDeclaration(FunctionDeclaration *p) = 0;
  virtual void visitFunctionDefinition(FunctionDefinition *p) = 0;
  virtual void visitFunctionDomain(FunctionDomain *p) = 0;
  virtual void visitFunctionRangeSingle(FunctionRangeSingle *p) = 0;
  virtual void visitFunctionRangeMultiple(FunctionRangeMultiple *p) = 0;
  virtual void visitFunctionParameter(FunctionParameter *p) = 0;
  virtual void visitFunctionRangeSingleNamed(FunctionRangeSingleNamed *p) = 0;
  virtual void visitFunctionRangeMultipleNamed(FunctionRangeMultipleNamed *p) = 0;
  virtual void visitStatementVarDecl(StatementVarDecl *p) = 0;
  virtual void visitStatementVarDef(StatementVarDef *p) = 0;
  virtual void visitStatementVarDefAsc(StatementVarDefAsc *p) = 0;
  virtual void visitStatementAssignment(StatementAssignment *p) = 0;
  virtual void visitStatementIf(StatementIf *p) = 0;
  virtual void visitStatementWhile(StatementWhile *p) = 0;
  virtual void visitStatementFor(StatementFor *p) = 0;
  virtual void visitStatementReturnNone(StatementReturnNone *p) = 0;
  virtual void visitStatementReturnValue(StatementReturnValue *p) = 0;
  virtual void visitStatementFunctionCall(StatementFunctionCall *p) = 0;
  virtual void visitIfStatement(IfStatement *p) = 0;
  virtual void visitIfElseIfStatement(IfElseIfStatement *p) = 0;
  virtual void visitIfElseStatement(IfElseStatement *p) = 0;
  virtual void visitBody(Body *p) = 0;
  virtual void visitValueArrowed(ValueArrowed *p) = 0;
  virtual void visitValueBraced(ValueBraced *p) = 0;
  virtual void visitMethodReference(MethodReference *p) = 0;
  virtual void visitRelationalEquals(RelationalEquals *p) = 0;
  virtual void visitRelationalNotEquals(RelationalNotEquals *p) = 0;
  virtual void visitRelationalLess(RelationalLess *p) = 0;
  virtual void visitRelationalGreater(RelationalGreater *p) = 0;
  virtual void visitRelationalLessOrEqual(RelationalLessOrEqual *p) = 0;
  virtual void visitRelationalGreaterOrEqual(RelationalGreaterOrEqual *p) = 0;
  virtual void visitArithmeticSum(ArithmeticSum *p) = 0;
  virtual void visitArithmeticDifference(ArithmeticDifference *p) = 0;
  virtual void visitArithmeticProduct(ArithmeticProduct *p) = 0;
  virtual void visitArithmeticQuotient(ArithmeticQuotient *p) = 0;
  virtual void visitArithmeticModulus(ArithmeticModulus *p) = 0;
  virtual void visitArithmeticExponentiation(ArithmeticExponentiation *p) = 0;
  virtual void visitLogicalUnaryNot(LogicalUnaryNot *p) = 0;
  virtual void visitLogicalConjunction(LogicalConjunction *p) = 0;
  virtual void visitLogicalDisjunction(LogicalDisjunction *p) = 0;
  virtual void visitLogicalExclusiveDisjunction(LogicalExclusiveDisjunction *p) = 0;
  virtual void visitLogicalImplication(LogicalImplication *p) = 0;
  virtual void visitLogicalEquivalence(LogicalEquivalence *p) = 0;
  virtual void visitUnaryHashCode(UnaryHashCode *p) = 0;
  virtual void visitUnaryMinus(UnaryMinus *p) = 0;
  virtual void visitTrueTerm(TrueTerm *p) = 0;
  virtual void visitFalseTerm(FalseTerm *p) = 0;
  virtual void visitEmptyTerm(EmptyTerm *p) = 0;
  virtual void visitStringTerm(StringTerm *p) = 0;
  virtual void visitIntegerTerm(IntegerTerm *p) = 0;
  virtual void visitDoubleTerm(DoubleTerm *p) = 0;
  virtual void visitVariableReferenceTerm(VariableReferenceTerm *p) = 0;
  virtual void visitArrayReferenceTerm(ArrayReferenceTerm *p) = 0;
  virtual void visitFieldReferenceTerm(FieldReferenceTerm *p) = 0;
  virtual void visitFunctionCallExpr(FunctionCallExpr *p) = 0;
  virtual void visitFunctionCall(FunctionCall *p) = 0;
  virtual void visitArrayInitializer(ArrayInitializer *p) = 0;
  virtual void visitRangeExpressionTerm(RangeExpressionTerm *p) = 0;
  virtual void visitRangeExpression(RangeExpression *p) = 0;
  virtual void visitSteppedRangeExpression(SteppedRangeExpression *p) = 0;
  virtual void visitOpenRange(OpenRange *p) = 0;
  virtual void visitClosedRange(ClosedRange *p) = 0;
  virtual void visitLeftClosedRightOpenedRange(LeftClosedRightOpenedRange *p) = 0;
  virtual void visitLeftOpenedRightClosedRange(LeftOpenedRightClosedRange *p) = 0;
  virtual void visitRangeBody(RangeBody *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListFieldDef(ListFieldDef *p) = 0;
  virtual void visitListTypeReference(ListTypeReference *p) = 0;
  virtual void visitListFuncParam(ListFuncParam *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListExpression(ListExpression *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program_ : public Visitable
{
public:
  virtual Program_ *clone() const = 0;

};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;

};

class TypeReference : public Visitable
{
public:
  virtual TypeReference *clone() const = 0;

};

class ClassDecl : public Visitable
{
public:
  virtual ClassDecl *clone() const = 0;

};

class Extends : public Visitable
{
public:
  virtual Extends *clone() const = 0;

};

class FieldDef : public Visitable
{
public:
  virtual FieldDef *clone() const = 0;

};

class Statics : public Visitable
{
public:
  virtual Statics *clone() const = 0;

};

class CBody : public Visitable
{
public:
  virtual CBody *clone() const = 0;

};

class FuncDecl : public Visitable
{
public:
  virtual FuncDecl *clone() const = 0;

};

class FuncDefn : public Visitable
{
public:
  virtual FuncDefn *clone() const = 0;

};

class FuncDomain : public Visitable
{
public:
  virtual FuncDomain *clone() const = 0;

};

class FuncRange : public Visitable
{
public:
  virtual FuncRange *clone() const = 0;

};

class FuncParam : public Visitable
{
public:
  virtual FuncParam *clone() const = 0;

};

class FuncRangeNamed : public Visitable
{
public:
  virtual FuncRangeNamed *clone() const = 0;

};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;

};

class StatementIf_ : public Visitable
{
public:
  virtual StatementIf_ *clone() const = 0;

};

class Body_ : public Visitable
{
public:
  virtual Body_ *clone() const = 0;

};

class Value : public Visitable
{
public:
  virtual Value *clone() const = 0;

};

class Expression : public Visitable
{
public:
  virtual Expression *clone() const = 0;

};

class FuncCall : public Visitable
{
public:
  virtual FuncCall *clone() const = 0;

};

class RangeExpr : public Visitable
{
public:
  virtual RangeExpr *clone() const = 0;

};

class UnsteppedRangeExpression : public Visitable
{
public:
  virtual UnsteppedRangeExpression *clone() const = 0;

};

class RangeBody_ : public Visitable
{
public:
  virtual RangeBody_ *clone() const = 0;

};



class Program : public Program_
{
public:
  ListDecl *listdecl_;
  ListStatement *liststatement_;

  Program(const Program &);
  Program &operator=(const Program &);
  Program(ListDecl *p1, ListStatement *p2);
  ~Program();
  virtual void accept(Visitor *v);
  virtual Program *clone() const;
  void swap(Program &);
};

class Declaration : public Decl
{
public:
  Ident ident_;
  TypeReference *typereference_;

  Declaration(const Declaration &);
  Declaration &operator=(const Declaration &);
  Declaration(Ident p1, TypeReference *p2);
  ~Declaration();
  virtual void accept(Visitor *v);
  virtual Declaration *clone() const;
  void swap(Declaration &);
};

class NothingType : public TypeReference
{
public:

  NothingType(const NothingType &);
  NothingType &operator=(const NothingType &);
  NothingType();
  ~NothingType();
  virtual void accept(Visitor *v);
  virtual NothingType *clone() const;
  void swap(NothingType &);
};

class BoolType : public TypeReference
{
public:

  BoolType(const BoolType &);
  BoolType &operator=(const BoolType &);
  BoolType();
  ~BoolType();
  virtual void accept(Visitor *v);
  virtual BoolType *clone() const;
  void swap(BoolType &);
};

class IntegerType : public TypeReference
{
public:

  IntegerType(const IntegerType &);
  IntegerType &operator=(const IntegerType &);
  IntegerType();
  ~IntegerType();
  virtual void accept(Visitor *v);
  virtual IntegerType *clone() const;
  void swap(IntegerType &);
};

class DoubleType : public TypeReference
{
public:

  DoubleType(const DoubleType &);
  DoubleType &operator=(const DoubleType &);
  DoubleType();
  ~DoubleType();
  virtual void accept(Visitor *v);
  virtual DoubleType *clone() const;
  void swap(DoubleType &);
};

class StringType : public TypeReference
{
public:

  StringType(const StringType &);
  StringType &operator=(const StringType &);
  StringType();
  ~StringType();
  virtual void accept(Visitor *v);
  virtual StringType *clone() const;
  void swap(StringType &);
};

class AutoType : public TypeReference
{
public:

  AutoType(const AutoType &);
  AutoType &operator=(const AutoType &);
  AutoType();
  ~AutoType();
  virtual void accept(Visitor *v);
  virtual AutoType *clone() const;
  void swap(AutoType &);
};

class FunctionDeclType : public TypeReference
{
public:
  FuncDecl *funcdecl_;

  FunctionDeclType(const FunctionDeclType &);
  FunctionDeclType &operator=(const FunctionDeclType &);
  FunctionDeclType(FuncDecl *p1);
  ~FunctionDeclType();
  virtual void accept(Visitor *v);
  virtual FunctionDeclType *clone() const;
  void swap(FunctionDeclType &);
};

class FunctionDefType : public TypeReference
{
public:
  FuncDefn *funcdefn_;

  FunctionDefType(const FunctionDefType &);
  FunctionDefType &operator=(const FunctionDefType &);
  FunctionDefType(FuncDefn *p1);
  ~FunctionDefType();
  virtual void accept(Visitor *v);
  virtual FunctionDefType *clone() const;
  void swap(FunctionDefType &);
};

class ArrayType : public TypeReference
{
public:
  TypeReference *typereference_;

  ArrayType(const ArrayType &);
  ArrayType &operator=(const ArrayType &);
  ArrayType(TypeReference *p1);
  ~ArrayType();
  virtual void accept(Visitor *v);
  virtual ArrayType *clone() const;
  void swap(ArrayType &);
};

class ClassType : public TypeReference
{
public:
  ClassDecl *classdecl_;

  ClassType(const ClassType &);
  ClassType &operator=(const ClassType &);
  ClassType(ClassDecl *p1);
  ~ClassType();
  virtual void accept(Visitor *v);
  virtual ClassType *clone() const;
  void swap(ClassType &);
};

class UserType : public TypeReference
{
public:
  Ident ident_;

  UserType(const UserType &);
  UserType &operator=(const UserType &);
  UserType(Ident p1);
  ~UserType();
  virtual void accept(Visitor *v);
  virtual UserType *clone() const;
  void swap(UserType &);
};

class ClassDeclaration : public ClassDecl
{
public:
  Extends *extends_;
  Statics *statics_;
  CBody *cbody_;

  ClassDeclaration(const ClassDeclaration &);
  ClassDeclaration &operator=(const ClassDeclaration &);
  ClassDeclaration(Extends *p1, Statics *p2, CBody *p3);
  ~ClassDeclaration();
  virtual void accept(Visitor *v);
  virtual ClassDeclaration *clone() const;
  void swap(ClassDeclaration &);
};

class ExtendsEmpty : public Extends
{
public:

  ExtendsEmpty(const ExtendsEmpty &);
  ExtendsEmpty &operator=(const ExtendsEmpty &);
  ExtendsEmpty();
  ~ExtendsEmpty();
  virtual void accept(Visitor *v);
  virtual ExtendsEmpty *clone() const;
  void swap(ExtendsEmpty &);
};

class ExtendsList : public Extends
{
public:
  Ident ident_;

  ExtendsList(const ExtendsList &);
  ExtendsList &operator=(const ExtendsList &);
  ExtendsList(Ident p1);
  ~ExtendsList();
  virtual void accept(Visitor *v);
  virtual ExtendsList *clone() const;
  void swap(ExtendsList &);
};

class FieldDeclaration : public FieldDef
{
public:
  Ident ident_;
  TypeReference *typereference_;

  FieldDeclaration(const FieldDeclaration &);
  FieldDeclaration &operator=(const FieldDeclaration &);
  FieldDeclaration(Ident p1, TypeReference *p2);
  ~FieldDeclaration();
  virtual void accept(Visitor *v);
  virtual FieldDeclaration *clone() const;
  void swap(FieldDeclaration &);
};

class FieldDefinition : public FieldDef
{
public:
  Ident ident_;
  Value *value_;

  FieldDefinition(const FieldDefinition &);
  FieldDefinition &operator=(const FieldDefinition &);
  FieldDefinition(Ident p1, Value *p2);
  ~FieldDefinition();
  virtual void accept(Visitor *v);
  virtual FieldDefinition *clone() const;
  void swap(FieldDefinition &);
};

class FieldDefinitionAsc : public FieldDef
{
public:
  Ident ident_;
  TypeReference *typereference_;
  Value *value_;

  FieldDefinitionAsc(const FieldDefinitionAsc &);
  FieldDefinitionAsc &operator=(const FieldDefinitionAsc &);
  FieldDefinitionAsc(Ident p1, TypeReference *p2, Value *p3);
  ~FieldDefinitionAsc();
  virtual void accept(Visitor *v);
  virtual FieldDefinitionAsc *clone() const;
  void swap(FieldDefinitionAsc &);
};

class StaticsEmpty : public Statics
{
public:

  StaticsEmpty(const StaticsEmpty &);
  StaticsEmpty &operator=(const StaticsEmpty &);
  StaticsEmpty();
  ~StaticsEmpty();
  virtual void accept(Visitor *v);
  virtual StaticsEmpty *clone() const;
  void swap(StaticsEmpty &);
};

class StaticsBody : public Statics
{
public:
  ListFieldDef *listfielddef_;

  StaticsBody(const StaticsBody &);
  StaticsBody &operator=(const StaticsBody &);
  StaticsBody(ListFieldDef *p1);
  ~StaticsBody();
  virtual void accept(Visitor *v);
  virtual StaticsBody *clone() const;
  void swap(StaticsBody &);
};

class ClassBody : public CBody
{
public:
  ListFieldDef *listfielddef_;

  ClassBody(const ClassBody &);
  ClassBody &operator=(const ClassBody &);
  ClassBody(ListFieldDef *p1);
  ~ClassBody();
  virtual void accept(Visitor *v);
  virtual ClassBody *clone() const;
  void swap(ClassBody &);
};

class FunctionDeclaration : public FuncDecl
{
public:
  FuncRange *funcrange_;
  FuncDomain *funcdomain_;

  FunctionDeclaration(const FunctionDeclaration &);
  FunctionDeclaration &operator=(const FunctionDeclaration &);
  FunctionDeclaration(FuncRange *p1, FuncDomain *p2);
  ~FunctionDeclaration();
  virtual void accept(Visitor *v);
  virtual FunctionDeclaration *clone() const;
  void swap(FunctionDeclaration &);
};

class FunctionDefinition : public FuncDefn
{
public:
  FuncRangeNamed *funcrangenamed_;
  FuncDomain *funcdomain_;
  Body_ *body__;

  FunctionDefinition(const FunctionDefinition &);
  FunctionDefinition &operator=(const FunctionDefinition &);
  FunctionDefinition(FuncRangeNamed *p1, FuncDomain *p2, Body_ *p3);
  ~FunctionDefinition();
  virtual void accept(Visitor *v);
  virtual FunctionDefinition *clone() const;
  void swap(FunctionDefinition &);
};

class FunctionDomain : public FuncDomain
{
public:
  TypeReference *typereference_;

  FunctionDomain(const FunctionDomain &);
  FunctionDomain &operator=(const FunctionDomain &);
  FunctionDomain(TypeReference *p1);
  ~FunctionDomain();
  virtual void accept(Visitor *v);
  virtual FunctionDomain *clone() const;
  void swap(FunctionDomain &);
};

class FunctionRangeSingle : public FuncRange
{
public:
  TypeReference *typereference_;

  FunctionRangeSingle(const FunctionRangeSingle &);
  FunctionRangeSingle &operator=(const FunctionRangeSingle &);
  FunctionRangeSingle(TypeReference *p1);
  ~FunctionRangeSingle();
  virtual void accept(Visitor *v);
  virtual FunctionRangeSingle *clone() const;
  void swap(FunctionRangeSingle &);
};

class FunctionRangeMultiple : public FuncRange
{
public:
  TypeReference *typereference_;
  ListTypeReference *listtypereference_;

  FunctionRangeMultiple(const FunctionRangeMultiple &);
  FunctionRangeMultiple &operator=(const FunctionRangeMultiple &);
  FunctionRangeMultiple(TypeReference *p1, ListTypeReference *p2);
  ~FunctionRangeMultiple();
  virtual void accept(Visitor *v);
  virtual FunctionRangeMultiple *clone() const;
  void swap(FunctionRangeMultiple &);
};

class FunctionParameter : public FuncParam
{
public:
  TypeReference *typereference_;
  Ident ident_;

  FunctionParameter(const FunctionParameter &);
  FunctionParameter &operator=(const FunctionParameter &);
  FunctionParameter(TypeReference *p1, Ident p2);
  ~FunctionParameter();
  virtual void accept(Visitor *v);
  virtual FunctionParameter *clone() const;
  void swap(FunctionParameter &);
};

class FunctionRangeSingleNamed : public FuncRangeNamed
{
public:
  FuncParam *funcparam_;

  FunctionRangeSingleNamed(const FunctionRangeSingleNamed &);
  FunctionRangeSingleNamed &operator=(const FunctionRangeSingleNamed &);
  FunctionRangeSingleNamed(FuncParam *p1);
  ~FunctionRangeSingleNamed();
  virtual void accept(Visitor *v);
  virtual FunctionRangeSingleNamed *clone() const;
  void swap(FunctionRangeSingleNamed &);
};

class FunctionRangeMultipleNamed : public FuncRangeNamed
{
public:
  ListFuncParam *listfuncparam_;

  FunctionRangeMultipleNamed(const FunctionRangeMultipleNamed &);
  FunctionRangeMultipleNamed &operator=(const FunctionRangeMultipleNamed &);
  FunctionRangeMultipleNamed(ListFuncParam *p1);
  ~FunctionRangeMultipleNamed();
  virtual void accept(Visitor *v);
  virtual FunctionRangeMultipleNamed *clone() const;
  void swap(FunctionRangeMultipleNamed &);
};

class StatementVarDecl : public Statement
{
public:
  Ident ident_;
  TypeReference *typereference_;

  StatementVarDecl(const StatementVarDecl &);
  StatementVarDecl &operator=(const StatementVarDecl &);
  StatementVarDecl(Ident p1, TypeReference *p2);
  ~StatementVarDecl();
  virtual void accept(Visitor *v);
  virtual StatementVarDecl *clone() const;
  void swap(StatementVarDecl &);
};

class StatementVarDef : public Statement
{
public:
  Ident ident_;
  Value *value_;

  StatementVarDef(const StatementVarDef &);
  StatementVarDef &operator=(const StatementVarDef &);
  StatementVarDef(Ident p1, Value *p2);
  ~StatementVarDef();
  virtual void accept(Visitor *v);
  virtual StatementVarDef *clone() const;
  void swap(StatementVarDef &);
};

class StatementVarDefAsc : public Statement
{
public:
  Ident ident_;
  TypeReference *typereference_;
  Value *value_;

  StatementVarDefAsc(const StatementVarDefAsc &);
  StatementVarDefAsc &operator=(const StatementVarDefAsc &);
  StatementVarDefAsc(Ident p1, TypeReference *p2, Value *p3);
  ~StatementVarDefAsc();
  virtual void accept(Visitor *v);
  virtual StatementVarDefAsc *clone() const;
  void swap(StatementVarDefAsc &);
};

class StatementAssignment : public Statement
{
public:
  Expression *expression_;
  Value *value_;

  StatementAssignment(const StatementAssignment &);
  StatementAssignment &operator=(const StatementAssignment &);
  StatementAssignment(Expression *p1, Value *p2);
  ~StatementAssignment();
  virtual void accept(Visitor *v);
  virtual StatementAssignment *clone() const;
  void swap(StatementAssignment &);
};

class StatementIf : public Statement
{
public:
  StatementIf_ *statementif__;

  StatementIf(const StatementIf &);
  StatementIf &operator=(const StatementIf &);
  StatementIf(StatementIf_ *p1);
  ~StatementIf();
  virtual void accept(Visitor *v);
  virtual StatementIf *clone() const;
  void swap(StatementIf &);
};

class StatementWhile : public Statement
{
public:
  Expression *expression_;
  Body_ *body__;

  StatementWhile(const StatementWhile &);
  StatementWhile &operator=(const StatementWhile &);
  StatementWhile(Expression *p1, Body_ *p2);
  ~StatementWhile();
  virtual void accept(Visitor *v);
  virtual StatementWhile *clone() const;
  void swap(StatementWhile &);
};

class StatementFor : public Statement
{
public:
  Ident ident_;
  RangeExpr *rangeexpr_;
  Body_ *body__;

  StatementFor(const StatementFor &);
  StatementFor &operator=(const StatementFor &);
  StatementFor(Ident p1, RangeExpr *p2, Body_ *p3);
  ~StatementFor();
  virtual void accept(Visitor *v);
  virtual StatementFor *clone() const;
  void swap(StatementFor &);
};

class StatementReturnNone : public Statement
{
public:

  StatementReturnNone(const StatementReturnNone &);
  StatementReturnNone &operator=(const StatementReturnNone &);
  StatementReturnNone();
  ~StatementReturnNone();
  virtual void accept(Visitor *v);
  virtual StatementReturnNone *clone() const;
  void swap(StatementReturnNone &);
};

class StatementReturnValue : public Statement
{
public:
  Expression *expression_;

  StatementReturnValue(const StatementReturnValue &);
  StatementReturnValue &operator=(const StatementReturnValue &);
  StatementReturnValue(Expression *p1);
  ~StatementReturnValue();
  virtual void accept(Visitor *v);
  virtual StatementReturnValue *clone() const;
  void swap(StatementReturnValue &);
};

class StatementFunctionCall : public Statement
{
public:
  FuncCall *funccall_;

  StatementFunctionCall(const StatementFunctionCall &);
  StatementFunctionCall &operator=(const StatementFunctionCall &);
  StatementFunctionCall(FuncCall *p1);
  ~StatementFunctionCall();
  virtual void accept(Visitor *v);
  virtual StatementFunctionCall *clone() const;
  void swap(StatementFunctionCall &);
};

class IfStatement : public StatementIf_
{
public:
  Expression *expression_;
  Body_ *body__;

  IfStatement(const IfStatement &);
  IfStatement &operator=(const IfStatement &);
  IfStatement(Expression *p1, Body_ *p2);
  ~IfStatement();
  virtual void accept(Visitor *v);
  virtual IfStatement *clone() const;
  void swap(IfStatement &);
};

class IfElseIfStatement : public StatementIf_
{
public:
  Expression *expression_;
  Body_ *body__;
  StatementIf_ *statementif__;

  IfElseIfStatement(const IfElseIfStatement &);
  IfElseIfStatement &operator=(const IfElseIfStatement &);
  IfElseIfStatement(Expression *p1, Body_ *p2, StatementIf_ *p3);
  ~IfElseIfStatement();
  virtual void accept(Visitor *v);
  virtual IfElseIfStatement *clone() const;
  void swap(IfElseIfStatement &);
};

class IfElseStatement : public StatementIf_
{
public:
  Expression *expression_;
  Body_ *body__1;
  Body_ *body__2;

  IfElseStatement(const IfElseStatement &);
  IfElseStatement &operator=(const IfElseStatement &);
  IfElseStatement(Expression *p1, Body_ *p2, Body_ *p3);
  ~IfElseStatement();
  virtual void accept(Visitor *v);
  virtual IfElseStatement *clone() const;
  void swap(IfElseStatement &);
};

class Body : public Body_
{
public:
  ListStatement *liststatement_;

  Body(const Body &);
  Body &operator=(const Body &);
  Body(ListStatement *p1);
  ~Body();
  virtual void accept(Visitor *v);
  virtual Body *clone() const;
  void swap(Body &);
};

class ValueArrowed : public Value
{
public:
  Expression *expression_;

  ValueArrowed(const ValueArrowed &);
  ValueArrowed &operator=(const ValueArrowed &);
  ValueArrowed(Expression *p1);
  ~ValueArrowed();
  virtual void accept(Visitor *v);
  virtual ValueArrowed *clone() const;
  void swap(ValueArrowed &);
};

class ValueBraced : public Value
{
public:
  Expression *expression_;

  ValueBraced(const ValueBraced &);
  ValueBraced &operator=(const ValueBraced &);
  ValueBraced(Expression *p1);
  ~ValueBraced();
  virtual void accept(Visitor *v);
  virtual ValueBraced *clone() const;
  void swap(ValueBraced &);
};

class MethodReference : public Expression
{
public:
  Expression *expression_;
  Ident ident_;

  MethodReference(const MethodReference &);
  MethodReference &operator=(const MethodReference &);
  MethodReference(Expression *p1, Ident p2);
  ~MethodReference();
  virtual void accept(Visitor *v);
  virtual MethodReference *clone() const;
  void swap(MethodReference &);
};

class RelationalEquals : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalEquals(const RelationalEquals &);
  RelationalEquals &operator=(const RelationalEquals &);
  RelationalEquals(Expression *p1, Expression *p2);
  ~RelationalEquals();
  virtual void accept(Visitor *v);
  virtual RelationalEquals *clone() const;
  void swap(RelationalEquals &);
};

class RelationalNotEquals : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalNotEquals(const RelationalNotEquals &);
  RelationalNotEquals &operator=(const RelationalNotEquals &);
  RelationalNotEquals(Expression *p1, Expression *p2);
  ~RelationalNotEquals();
  virtual void accept(Visitor *v);
  virtual RelationalNotEquals *clone() const;
  void swap(RelationalNotEquals &);
};

class RelationalLess : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalLess(const RelationalLess &);
  RelationalLess &operator=(const RelationalLess &);
  RelationalLess(Expression *p1, Expression *p2);
  ~RelationalLess();
  virtual void accept(Visitor *v);
  virtual RelationalLess *clone() const;
  void swap(RelationalLess &);
};

class RelationalGreater : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalGreater(const RelationalGreater &);
  RelationalGreater &operator=(const RelationalGreater &);
  RelationalGreater(Expression *p1, Expression *p2);
  ~RelationalGreater();
  virtual void accept(Visitor *v);
  virtual RelationalGreater *clone() const;
  void swap(RelationalGreater &);
};

class RelationalLessOrEqual : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalLessOrEqual(const RelationalLessOrEqual &);
  RelationalLessOrEqual &operator=(const RelationalLessOrEqual &);
  RelationalLessOrEqual(Expression *p1, Expression *p2);
  ~RelationalLessOrEqual();
  virtual void accept(Visitor *v);
  virtual RelationalLessOrEqual *clone() const;
  void swap(RelationalLessOrEqual &);
};

class RelationalGreaterOrEqual : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  RelationalGreaterOrEqual(const RelationalGreaterOrEqual &);
  RelationalGreaterOrEqual &operator=(const RelationalGreaterOrEqual &);
  RelationalGreaterOrEqual(Expression *p1, Expression *p2);
  ~RelationalGreaterOrEqual();
  virtual void accept(Visitor *v);
  virtual RelationalGreaterOrEqual *clone() const;
  void swap(RelationalGreaterOrEqual &);
};

class ArithmeticSum : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticSum(const ArithmeticSum &);
  ArithmeticSum &operator=(const ArithmeticSum &);
  ArithmeticSum(Expression *p1, Expression *p2);
  ~ArithmeticSum();
  virtual void accept(Visitor *v);
  virtual ArithmeticSum *clone() const;
  void swap(ArithmeticSum &);
};

class ArithmeticDifference : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticDifference(const ArithmeticDifference &);
  ArithmeticDifference &operator=(const ArithmeticDifference &);
  ArithmeticDifference(Expression *p1, Expression *p2);
  ~ArithmeticDifference();
  virtual void accept(Visitor *v);
  virtual ArithmeticDifference *clone() const;
  void swap(ArithmeticDifference &);
};

class ArithmeticProduct : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticProduct(const ArithmeticProduct &);
  ArithmeticProduct &operator=(const ArithmeticProduct &);
  ArithmeticProduct(Expression *p1, Expression *p2);
  ~ArithmeticProduct();
  virtual void accept(Visitor *v);
  virtual ArithmeticProduct *clone() const;
  void swap(ArithmeticProduct &);
};

class ArithmeticQuotient : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticQuotient(const ArithmeticQuotient &);
  ArithmeticQuotient &operator=(const ArithmeticQuotient &);
  ArithmeticQuotient(Expression *p1, Expression *p2);
  ~ArithmeticQuotient();
  virtual void accept(Visitor *v);
  virtual ArithmeticQuotient *clone() const;
  void swap(ArithmeticQuotient &);
};

class ArithmeticModulus : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticModulus(const ArithmeticModulus &);
  ArithmeticModulus &operator=(const ArithmeticModulus &);
  ArithmeticModulus(Expression *p1, Expression *p2);
  ~ArithmeticModulus();
  virtual void accept(Visitor *v);
  virtual ArithmeticModulus *clone() const;
  void swap(ArithmeticModulus &);
};

class ArithmeticExponentiation : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArithmeticExponentiation(const ArithmeticExponentiation &);
  ArithmeticExponentiation &operator=(const ArithmeticExponentiation &);
  ArithmeticExponentiation(Expression *p1, Expression *p2);
  ~ArithmeticExponentiation();
  virtual void accept(Visitor *v);
  virtual ArithmeticExponentiation *clone() const;
  void swap(ArithmeticExponentiation &);
};

class LogicalUnaryNot : public Expression
{
public:
  Expression *expression_;

  LogicalUnaryNot(const LogicalUnaryNot &);
  LogicalUnaryNot &operator=(const LogicalUnaryNot &);
  LogicalUnaryNot(Expression *p1);
  ~LogicalUnaryNot();
  virtual void accept(Visitor *v);
  virtual LogicalUnaryNot *clone() const;
  void swap(LogicalUnaryNot &);
};

class LogicalConjunction : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LogicalConjunction(const LogicalConjunction &);
  LogicalConjunction &operator=(const LogicalConjunction &);
  LogicalConjunction(Expression *p1, Expression *p2);
  ~LogicalConjunction();
  virtual void accept(Visitor *v);
  virtual LogicalConjunction *clone() const;
  void swap(LogicalConjunction &);
};

class LogicalDisjunction : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LogicalDisjunction(const LogicalDisjunction &);
  LogicalDisjunction &operator=(const LogicalDisjunction &);
  LogicalDisjunction(Expression *p1, Expression *p2);
  ~LogicalDisjunction();
  virtual void accept(Visitor *v);
  virtual LogicalDisjunction *clone() const;
  void swap(LogicalDisjunction &);
};

class LogicalExclusiveDisjunction : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LogicalExclusiveDisjunction(const LogicalExclusiveDisjunction &);
  LogicalExclusiveDisjunction &operator=(const LogicalExclusiveDisjunction &);
  LogicalExclusiveDisjunction(Expression *p1, Expression *p2);
  ~LogicalExclusiveDisjunction();
  virtual void accept(Visitor *v);
  virtual LogicalExclusiveDisjunction *clone() const;
  void swap(LogicalExclusiveDisjunction &);
};

class LogicalImplication : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LogicalImplication(const LogicalImplication &);
  LogicalImplication &operator=(const LogicalImplication &);
  LogicalImplication(Expression *p1, Expression *p2);
  ~LogicalImplication();
  virtual void accept(Visitor *v);
  virtual LogicalImplication *clone() const;
  void swap(LogicalImplication &);
};

class LogicalEquivalence : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  LogicalEquivalence(const LogicalEquivalence &);
  LogicalEquivalence &operator=(const LogicalEquivalence &);
  LogicalEquivalence(Expression *p1, Expression *p2);
  ~LogicalEquivalence();
  virtual void accept(Visitor *v);
  virtual LogicalEquivalence *clone() const;
  void swap(LogicalEquivalence &);
};

class UnaryHashCode : public Expression
{
public:
  Expression *expression_;

  UnaryHashCode(const UnaryHashCode &);
  UnaryHashCode &operator=(const UnaryHashCode &);
  UnaryHashCode(Expression *p1);
  ~UnaryHashCode();
  virtual void accept(Visitor *v);
  virtual UnaryHashCode *clone() const;
  void swap(UnaryHashCode &);
};

class UnaryMinus : public Expression
{
public:
  Expression *expression_;

  UnaryMinus(const UnaryMinus &);
  UnaryMinus &operator=(const UnaryMinus &);
  UnaryMinus(Expression *p1);
  ~UnaryMinus();
  virtual void accept(Visitor *v);
  virtual UnaryMinus *clone() const;
  void swap(UnaryMinus &);
};

class TrueTerm : public Expression
{
public:

  TrueTerm(const TrueTerm &);
  TrueTerm &operator=(const TrueTerm &);
  TrueTerm();
  ~TrueTerm();
  virtual void accept(Visitor *v);
  virtual TrueTerm *clone() const;
  void swap(TrueTerm &);
};

class FalseTerm : public Expression
{
public:

  FalseTerm(const FalseTerm &);
  FalseTerm &operator=(const FalseTerm &);
  FalseTerm();
  ~FalseTerm();
  virtual void accept(Visitor *v);
  virtual FalseTerm *clone() const;
  void swap(FalseTerm &);
};

class EmptyTerm : public Expression
{
public:

  EmptyTerm(const EmptyTerm &);
  EmptyTerm &operator=(const EmptyTerm &);
  EmptyTerm();
  ~EmptyTerm();
  virtual void accept(Visitor *v);
  virtual EmptyTerm *clone() const;
  void swap(EmptyTerm &);
};

class StringTerm : public Expression
{
public:
  String string_;

  StringTerm(const StringTerm &);
  StringTerm &operator=(const StringTerm &);
  StringTerm(String p1);
  ~StringTerm();
  virtual void accept(Visitor *v);
  virtual StringTerm *clone() const;
  void swap(StringTerm &);
};

class IntegerTerm : public Expression
{
public:
  Integer integer_;

  IntegerTerm(const IntegerTerm &);
  IntegerTerm &operator=(const IntegerTerm &);
  IntegerTerm(Integer p1);
  ~IntegerTerm();
  virtual void accept(Visitor *v);
  virtual IntegerTerm *clone() const;
  void swap(IntegerTerm &);
};

class DoubleTerm : public Expression
{
public:
  Double double_;

  DoubleTerm(const DoubleTerm &);
  DoubleTerm &operator=(const DoubleTerm &);
  DoubleTerm(Double p1);
  ~DoubleTerm();
  virtual void accept(Visitor *v);
  virtual DoubleTerm *clone() const;
  void swap(DoubleTerm &);
};

class VariableReferenceTerm : public Expression
{
public:
  Ident ident_;

  VariableReferenceTerm(const VariableReferenceTerm &);
  VariableReferenceTerm &operator=(const VariableReferenceTerm &);
  VariableReferenceTerm(Ident p1);
  ~VariableReferenceTerm();
  virtual void accept(Visitor *v);
  virtual VariableReferenceTerm *clone() const;
  void swap(VariableReferenceTerm &);
};

class ArrayReferenceTerm : public Expression
{
public:
  Expression *expression_1;
  Expression *expression_2;

  ArrayReferenceTerm(const ArrayReferenceTerm &);
  ArrayReferenceTerm &operator=(const ArrayReferenceTerm &);
  ArrayReferenceTerm(Expression *p1, Expression *p2);
  ~ArrayReferenceTerm();
  virtual void accept(Visitor *v);
  virtual ArrayReferenceTerm *clone() const;
  void swap(ArrayReferenceTerm &);
};

class FieldReferenceTerm : public Expression
{
public:
  Expression *expression_;
  Ident ident_;

  FieldReferenceTerm(const FieldReferenceTerm &);
  FieldReferenceTerm &operator=(const FieldReferenceTerm &);
  FieldReferenceTerm(Expression *p1, Ident p2);
  ~FieldReferenceTerm();
  virtual void accept(Visitor *v);
  virtual FieldReferenceTerm *clone() const;
  void swap(FieldReferenceTerm &);
};

class FunctionCallExpr : public Expression
{
public:
  FuncCall *funccall_;

  FunctionCallExpr(const FunctionCallExpr &);
  FunctionCallExpr &operator=(const FunctionCallExpr &);
  FunctionCallExpr(FuncCall *p1);
  ~FunctionCallExpr();
  virtual void accept(Visitor *v);
  virtual FunctionCallExpr *clone() const;
  void swap(FunctionCallExpr &);
};

class ArrayInitializer : public Expression
{
public:
  ListExpression *listexpression_;

  ArrayInitializer(const ArrayInitializer &);
  ArrayInitializer &operator=(const ArrayInitializer &);
  ArrayInitializer(ListExpression *p1);
  ~ArrayInitializer();
  virtual void accept(Visitor *v);
  virtual ArrayInitializer *clone() const;
  void swap(ArrayInitializer &);
};

class RangeExpressionTerm : public Expression
{
public:
  RangeExpr *rangeexpr_;

  RangeExpressionTerm(const RangeExpressionTerm &);
  RangeExpressionTerm &operator=(const RangeExpressionTerm &);
  RangeExpressionTerm(RangeExpr *p1);
  ~RangeExpressionTerm();
  virtual void accept(Visitor *v);
  virtual RangeExpressionTerm *clone() const;
  void swap(RangeExpressionTerm &);
};

class FunctionCall : public FuncCall
{
public:
  Expression *expression_;
  ListExpression *listexpression_;

  FunctionCall(const FunctionCall &);
  FunctionCall &operator=(const FunctionCall &);
  FunctionCall(Expression *p1, ListExpression *p2);
  ~FunctionCall();
  virtual void accept(Visitor *v);
  virtual FunctionCall *clone() const;
  void swap(FunctionCall &);
};

class RangeExpression : public RangeExpr
{
public:
  UnsteppedRangeExpression *unsteppedrangeexpression_;

  RangeExpression(const RangeExpression &);
  RangeExpression &operator=(const RangeExpression &);
  RangeExpression(UnsteppedRangeExpression *p1);
  ~RangeExpression();
  virtual void accept(Visitor *v);
  virtual RangeExpression *clone() const;
  void swap(RangeExpression &);
};

class SteppedRangeExpression : public RangeExpr
{
public:
  UnsteppedRangeExpression *unsteppedrangeexpression_;
  Integer integer_;

  SteppedRangeExpression(const SteppedRangeExpression &);
  SteppedRangeExpression &operator=(const SteppedRangeExpression &);
  SteppedRangeExpression(UnsteppedRangeExpression *p1, Integer p2);
  ~SteppedRangeExpression();
  virtual void accept(Visitor *v);
  virtual SteppedRangeExpression *clone() const;
  void swap(SteppedRangeExpression &);
};

class OpenRange : public UnsteppedRangeExpression
{
public:
  RangeBody_ *rangebody__;

  OpenRange(const OpenRange &);
  OpenRange &operator=(const OpenRange &);
  OpenRange(RangeBody_ *p1);
  ~OpenRange();
  virtual void accept(Visitor *v);
  virtual OpenRange *clone() const;
  void swap(OpenRange &);
};

class ClosedRange : public UnsteppedRangeExpression
{
public:
  RangeBody_ *rangebody__;

  ClosedRange(const ClosedRange &);
  ClosedRange &operator=(const ClosedRange &);
  ClosedRange(RangeBody_ *p1);
  ~ClosedRange();
  virtual void accept(Visitor *v);
  virtual ClosedRange *clone() const;
  void swap(ClosedRange &);
};

class LeftClosedRightOpenedRange : public UnsteppedRangeExpression
{
public:
  RangeBody_ *rangebody__;

  LeftClosedRightOpenedRange(const LeftClosedRightOpenedRange &);
  LeftClosedRightOpenedRange &operator=(const LeftClosedRightOpenedRange &);
  LeftClosedRightOpenedRange(RangeBody_ *p1);
  ~LeftClosedRightOpenedRange();
  virtual void accept(Visitor *v);
  virtual LeftClosedRightOpenedRange *clone() const;
  void swap(LeftClosedRightOpenedRange &);
};

class LeftOpenedRightClosedRange : public UnsteppedRangeExpression
{
public:
  RangeBody_ *rangebody__;

  LeftOpenedRightClosedRange(const LeftOpenedRightClosedRange &);
  LeftOpenedRightClosedRange &operator=(const LeftOpenedRightClosedRange &);
  LeftOpenedRightClosedRange(RangeBody_ *p1);
  ~LeftOpenedRightClosedRange();
  virtual void accept(Visitor *v);
  virtual LeftOpenedRightClosedRange *clone() const;
  void swap(LeftOpenedRightClosedRange &);
};

class RangeBody : public RangeBody_
{
public:
  Integer integer_1;
  Integer integer_2;

  RangeBody(const RangeBody &);
  RangeBody &operator=(const RangeBody &);
  RangeBody(Integer p1, Integer p2);
  ~RangeBody();
  virtual void accept(Visitor *v);
  virtual RangeBody *clone() const;
  void swap(RangeBody &);
};



class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDecl *clone() const;
};

ListDecl* consListDecl(Decl* x, ListDecl* xs);

class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

ListIdent* consListIdent(Ident x, ListIdent* xs);

class ListFieldDef : public Visitable, public std::vector<FieldDef*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFieldDef *clone() const;
};

ListFieldDef* consListFieldDef(FieldDef* x, ListFieldDef* xs);

class ListTypeReference : public Visitable, public std::vector<TypeReference*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTypeReference *clone() const;
};

ListTypeReference* consListTypeReference(TypeReference* x, ListTypeReference* xs);

class ListFuncParam : public Visitable, public std::vector<FuncParam*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFuncParam *clone() const;
};

ListFuncParam* consListFuncParam(FuncParam* x, ListFuncParam* xs);

class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};

ListStatement* consListStatement(Statement* x, ListStatement* xs);

class ListExpression : public Visitable, public std::vector<Expression*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpression *clone() const;
};

ListExpression* consListExpression(Expression* x, ListExpression* xs);





#endif
