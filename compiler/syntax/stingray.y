/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the stingray_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE stingray__scan_string(const char *str, yyscan_t scanner);
extern void stingray__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void stingray_lex_destroy(yyscan_t scanner);
extern char* stingray_get_text(yyscan_t scanner);

extern yyscan_t stingray__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program_* program__;
  ListDecl* listdecl_;
  Decl* decl_;
  TypeReference* typereference_;
  ClassDecl* classdecl_;
  Extends* extends_;
  ListIdent* listident_;
  FieldDef* fielddef_;
  Statics* statics_;
  ListFieldDef* listfielddef_;
  CBody* cbody_;
  FuncDecl* funcdecl_;
  FuncDefn* funcdefn_;
  FuncDomain* funcdomain_;
  FuncRange* funcrange_;
  ListTypeReference* listtypereference_;
  FuncParam* funcparam_;
  FuncRangeNamed* funcrangenamed_;
  ListFuncParam* listfuncparam_;
  Statement* statement_;
  StatementIf_* statementif__;
  Body_* body__;
  Value* value_;
  ListStatement* liststatement_;
  Expression* expression_;
  FuncCall* funccall_;
  ListExpression* listexpression_;
  RangeExpr* rangeexpr_;
  UnsteppedRangeExpression* unsteppedrangeexpression_;
  RangeBody_* rangebody__;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, stingray_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ      /* != */
%token          _HASH        /* # */
%token          _PERCENT     /* % */
%token          _LPAREN      /* ( */
%token          _RPAREN      /* ) */
%token          _STAR        /* * */
%token          _PLUS        /* + */
%token          _COMMA       /* , */
%token          _MINUS       /* - */
%token          _RARROW      /* -> */
%token          _DOT         /* . */
%token          _SLASH       /* / */
%token          _COLON       /* : */
%token          _DCOLON      /* :: */
%token          _SEMI        /* ; */
%token          _LT          /* < */
%token          _LARROW      /* <- */
%token          _LDARROW     /* <= */
%token          _SYMB_23     /* <=> */
%token          _EQ          /* = */
%token          _RDARROW     /* => */
%token          _GT          /* > */
%token          _GTEQ        /* >= */
%token          _KW_Auto     /* Auto */
%token          _KW_Boolean  /* Boolean */
%token          _KW_Double   /* Double */
%token          _KW_Integer  /* Integer */
%token          _KW_Nothing  /* Nothing */
%token          _KW_String   /* String */
%token          _LBRACK      /* [ */
%token          _EMPTYBRACK  /* [] */
%token          _RBRACK      /* ] */
%token          _CARET       /* ^ */
%token          _KW_and      /* and */
%token          _KW_as       /* as */
%token          _KW_class    /* class */
%token          _KW_declare  /* declare */
%token          _KW_else     /* else */
%token          _KW_empty    /* empty */
%token          _KW_false    /* false */
%token          _KW_for      /* for */
%token          _KW_if       /* if */
%token          _KW_in       /* in */
%token          _KW_let      /* let */
%token          _KW_not      /* not */
%token          _KW_or       /* or */
%token          _KW_return   /* return */
%token          _KW_true     /* true */
%token          _KW_while    /* while */
%token          _KW_xor      /* xor */
%token          _LBRACE      /* { */
%token          _RBRACE      /* } */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program__> Program_
%type <listdecl_> ListDecl
%type <decl_> Decl
%type <typereference_> TypeReference
%type <classdecl_> ClassDecl
%type <extends_> Extends
%type <listident_> ListIdent
%type <fielddef_> FieldDef
%type <statics_> Statics
%type <listfielddef_> ListFieldDef
%type <cbody_> CBody
%type <funcdecl_> FuncDecl
%type <funcdefn_> FuncDefn
%type <funcdomain_> FuncDomain
%type <funcrange_> FuncRange
%type <listtypereference_> ListTypeReference
%type <funcparam_> FuncParam
%type <funcrangenamed_> FuncRangeNamed
%type <listfuncparam_> ListFuncParam
%type <statement_> Statement
%type <statementif__> StatementIf_
%type <body__> Body_
%type <value_> Value
%type <liststatement_> ListStatement
%type <expression_> Expression
%type <expression_> Expression5
%type <expression_> Expression6
%type <expression_> Expression7
%type <expression_> Expression8
%type <expression_> Expression4
%type <expression_> Expression3
%type <expression_> Expression2
%type <expression_> Expression1
%type <expression_> Expression9
%type <expression_> Expression10
%type <funccall_> FuncCall
%type <listexpression_> ListExpression
%type <rangeexpr_> RangeExpr
%type <unsteppedrangeexpression_> UnsteppedRangeExpression
%type <rangebody__> RangeBody_

%start Program_

%%

Program_ : ListDecl ListStatement { $$ = new Program($1, $2); result->program__ = $$; }
;
ListDecl : /* empty */ { $$ = new ListDecl(); result->listdecl_ = $$; }
  | ListDecl Decl { $1->push_back($2); $$ = $1; result->listdecl_ = $$; }
;
Decl : _KW_declare _IDENT_ _KW_as TypeReference { $$ = new Declaration($2, $4); result->decl_ = $$; }
;
TypeReference : _KW_Nothing { $$ = new NothingType(); result->typereference_ = $$; }
  | _KW_Boolean { $$ = new BoolType(); result->typereference_ = $$; }
  | _KW_Integer { $$ = new IntegerType(); result->typereference_ = $$; }
  | _KW_Double { $$ = new DoubleType(); result->typereference_ = $$; }
  | _KW_String { $$ = new StringType(); result->typereference_ = $$; }
  | _KW_Auto { $$ = new AutoType(); result->typereference_ = $$; }
  | FuncDecl { $$ = new FunctionDeclType($1); result->typereference_ = $$; }
  | FuncDefn { $$ = new FunctionDefType($1); result->typereference_ = $$; }
  | TypeReference _EMPTYBRACK { $$ = new ArrayType($1); result->typereference_ = $$; }
  | ClassDecl { $$ = new ClassType($1); result->typereference_ = $$; }
  | _IDENT_ { $$ = new UserType($1); result->typereference_ = $$; }
;
ClassDecl : _KW_class Extends Statics _LBRACE CBody _RBRACE { $$ = new ClassDeclaration($2, $3, $5); result->classdecl_ = $$; }
;
Extends : /* empty */ { $$ = new ExtendsEmpty(); result->extends_ = $$; }
  | _LT _IDENT_ _GT { $$ = new ExtendsList($2); result->extends_ = $$; }
;
ListIdent : /* empty */ { $$ = new ListIdent(); result->listident_ = $$; }
  | _IDENT_ { $$ = new ListIdent(); $$->push_back($1); result->listident_ = $$; }
  | _IDENT_ _COMMA ListIdent { $3->push_back($1); $$ = $3; result->listident_ = $$; }
;
FieldDef : _IDENT_ _COLON TypeReference { $$ = new FieldDeclaration($1, $3); result->fielddef_ = $$; }
  | _IDENT_ Value { $$ = new FieldDefinition($1, $2); result->fielddef_ = $$; }
  | _IDENT_ _COLON TypeReference Value { $$ = new FieldDefinitionAsc($1, $3, $4); result->fielddef_ = $$; }
;
Statics : /* empty */ { $$ = new StaticsEmpty(); result->statics_ = $$; }
  | _LPAREN ListFieldDef _RPAREN { std::reverse($2->begin(),$2->end()) ;$$ = new StaticsBody($2); result->statics_ = $$; }
;
ListFieldDef : /* empty */ { $$ = new ListFieldDef(); result->listfielddef_ = $$; }
  | FieldDef ListFieldDef { $2->push_back($1); $$ = $2; result->listfielddef_ = $$; }
  | /* empty */ { $$ = new ListFieldDef(); result->listfielddef_ = $$; }
  | FieldDef ListFieldDef { $2->push_back($1); $$ = $2; result->listfielddef_ = $$; }
;
CBody : ListFieldDef { std::reverse($1->begin(),$1->end()) ;$$ = new ClassBody($1); result->cbody_ = $$; }
;
FuncDecl : FuncRange _RARROW FuncDomain { $$ = new FunctionDeclaration($1, $3); result->funcdecl_ = $$; }
;
FuncDefn : FuncRangeNamed _RARROW FuncDomain Body_ { $$ = new FunctionDefinition($1, $3, $4); result->funcdefn_ = $$; }
;
FuncDomain : TypeReference { $$ = new FunctionDomain($1); result->funcdomain_ = $$; }
;
FuncRange : TypeReference { $$ = new FunctionRangeSingle($1); result->funcrange_ = $$; }
  | _LPAREN TypeReference _COMMA ListTypeReference _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new FunctionRangeMultiple($2, $4); result->funcrange_ = $$; }
;
ListTypeReference : /* empty */ { $$ = new ListTypeReference(); result->listtypereference_ = $$; }
  | TypeReference { $$ = new ListTypeReference(); $$->push_back($1); result->listtypereference_ = $$; }
  | TypeReference _COMMA ListTypeReference { $3->push_back($1); $$ = $3; result->listtypereference_ = $$; }
;
FuncParam : TypeReference _IDENT_ { $$ = new FunctionParameter($1, $2); result->funcparam_ = $$; }
;
FuncRangeNamed : FuncParam { $$ = new FunctionRangeSingleNamed($1); result->funcrangenamed_ = $$; }
  | _LPAREN ListFuncParam _RPAREN { std::reverse($2->begin(),$2->end()) ;$$ = new FunctionRangeMultipleNamed($2); result->funcrangenamed_ = $$; }
;
ListFuncParam : /* empty */ { $$ = new ListFuncParam(); result->listfuncparam_ = $$; }
  | FuncParam { $$ = new ListFuncParam(); $$->push_back($1); result->listfuncparam_ = $$; }
  | FuncParam _COMMA ListFuncParam { $3->push_back($1); $$ = $3; result->listfuncparam_ = $$; }
;
Statement : _KW_let _IDENT_ _COLON TypeReference { $$ = new StatementVarDecl($2, $4); result->statement_ = $$; }
  | _KW_let _IDENT_ Value { $$ = new StatementVarDef($2, $3); result->statement_ = $$; }
  | _KW_let _IDENT_ _COLON TypeReference Value { $$ = new StatementVarDefAsc($2, $4, $5); result->statement_ = $$; }
  | Expression Value { $$ = new StatementAssignment($1, $2); result->statement_ = $$; }
  | StatementIf_ { $$ = new StatementIf($1); result->statement_ = $$; }
  | _KW_while Expression Body_ { $$ = new StatementWhile($2, $3); result->statement_ = $$; }
  | _KW_for _IDENT_ _KW_in RangeExpr Body_ { $$ = new StatementFor($2, $4, $5); result->statement_ = $$; }
  | _KW_return { $$ = new StatementReturnNone(); result->statement_ = $$; }
  | _KW_return Expression { $$ = new StatementReturnValue($2); result->statement_ = $$; }
  | FuncCall { $$ = new StatementFunctionCall($1); result->statement_ = $$; }
;
StatementIf_ : _KW_if Expression Body_ { $$ = new IfStatement($2, $3); result->statementif__ = $$; }
  | _KW_if Expression Body_ _KW_else StatementIf_ { $$ = new IfElseIfStatement($2, $3, $5); result->statementif__ = $$; }
  | _KW_if Expression Body_ _KW_else Body_ { $$ = new IfElseStatement($2, $3, $5); result->statementif__ = $$; }
;
Body_ : _LBRACE ListStatement _RBRACE { $$ = new Body($2); result->body__ = $$; }
;
Value : _LARROW Expression { $$ = new ValueArrowed($2); result->value_ = $$; }
  | _LBRACE Expression _RBRACE { $$ = new ValueBraced($2); result->value_ = $$; }
;
ListStatement : /* empty */ { $$ = new ListStatement(); result->liststatement_ = $$; }
  | ListStatement Statement { $1->push_back($2); $$ = $1; result->liststatement_ = $$; }
;
Expression : Expression _DCOLON _IDENT_ { $$ = new MethodReference($1, $3); result->expression_ = $$; }
  | Expression1 { $$ = $1; result->expression_ = $$; }
;
Expression5 : Expression5 _EQ Expression6 { $$ = new RelationalEquals($1, $3); result->expression_ = $$; }
  | Expression5 _BANGEQ Expression6 { $$ = new RelationalNotEquals($1, $3); result->expression_ = $$; }
  | Expression5 _LT Expression6 { $$ = new RelationalLess($1, $3); result->expression_ = $$; }
  | Expression5 _GT Expression6 { $$ = new RelationalGreater($1, $3); result->expression_ = $$; }
  | Expression5 _LDARROW Expression6 { $$ = new RelationalLessOrEqual($1, $3); result->expression_ = $$; }
  | Expression5 _GTEQ Expression6 { $$ = new RelationalGreaterOrEqual($1, $3); result->expression_ = $$; }
  | Expression6 { $$ = $1; result->expression_ = $$; }
;
Expression6 : Expression6 _PLUS Expression7 { $$ = new ArithmeticSum($1, $3); result->expression_ = $$; }
  | Expression6 _MINUS Expression7 { $$ = new ArithmeticDifference($1, $3); result->expression_ = $$; }
  | Expression7 { $$ = $1; result->expression_ = $$; }
;
Expression7 : Expression7 _STAR Expression8 { $$ = new ArithmeticProduct($1, $3); result->expression_ = $$; }
  | Expression7 _SLASH Expression8 { $$ = new ArithmeticQuotient($1, $3); result->expression_ = $$; }
  | Expression7 _PERCENT Expression8 { $$ = new ArithmeticModulus($1, $3); result->expression_ = $$; }
  | Expression8 { $$ = $1; result->expression_ = $$; }
;
Expression8 : Expression8 _CARET Expression9 { $$ = new ArithmeticExponentiation($1, $3); result->expression_ = $$; }
  | Expression9 { $$ = $1; result->expression_ = $$; }
;
Expression4 : _KW_not Expression3 { $$ = new LogicalUnaryNot($2); result->expression_ = $$; }
  | Expression5 { $$ = $1; result->expression_ = $$; }
;
Expression3 : Expression3 _KW_and Expression4 { $$ = new LogicalConjunction($1, $3); result->expression_ = $$; }
  | Expression4 { $$ = $1; result->expression_ = $$; }
;
Expression2 : Expression2 _KW_or Expression3 { $$ = new LogicalDisjunction($1, $3); result->expression_ = $$; }
  | Expression2 _KW_xor Expression3 { $$ = new LogicalExclusiveDisjunction($1, $3); result->expression_ = $$; }
  | Expression3 { $$ = $1; result->expression_ = $$; }
;
Expression1 : Expression1 _RDARROW Expression2 { $$ = new LogicalImplication($1, $3); result->expression_ = $$; }
  | Expression1 _SYMB_23 Expression2 { $$ = new LogicalEquivalence($1, $3); result->expression_ = $$; }
  | Expression2 { $$ = $1; result->expression_ = $$; }
;
Expression9 : _LPAREN Expression _RPAREN { $$ = $2; result->expression_ = $$; }
  | Expression10 { $$ = $1; result->expression_ = $$; }
  | _HASH Expression10 { $$ = new UnaryHashCode($2); result->expression_ = $$; }
  | _MINUS Expression10 { $$ = new UnaryMinus($2); result->expression_ = $$; }
;
Expression10 : _LPAREN Expression _RPAREN { $$ = $2; result->expression_ = $$; }
  | _KW_true { $$ = new TrueTerm(); result->expression_ = $$; }
  | _KW_false { $$ = new FalseTerm(); result->expression_ = $$; }
  | _KW_empty { $$ = new EmptyTerm(); result->expression_ = $$; }
  | _STRING_ { $$ = new StringTerm($1); result->expression_ = $$; }
  | _INTEGER_ { $$ = new IntegerTerm($1); result->expression_ = $$; }
  | _DOUBLE_ { $$ = new DoubleTerm($1); result->expression_ = $$; }
  | _IDENT_ { $$ = new VariableReferenceTerm($1); result->expression_ = $$; }
  | Expression10 _LBRACK Expression _RBRACK { $$ = new ArrayReferenceTerm($1, $3); result->expression_ = $$; }
  | Expression10 _DOT _IDENT_ { $$ = new FieldReferenceTerm($1, $3); result->expression_ = $$; }
  | FuncCall { $$ = new FunctionCallExpr($1); result->expression_ = $$; }
  | _LBRACK ListExpression _RBRACK { std::reverse($2->begin(),$2->end()) ;$$ = new ArrayInitializer($2); result->expression_ = $$; }
  | RangeExpr { $$ = new RangeExpressionTerm($1); result->expression_ = $$; }
;
FuncCall : Expression10 _LPAREN ListExpression _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new FunctionCall($1, $3); result->funccall_ = $$; }
;
ListExpression : /* empty */ { $$ = new ListExpression(); result->listexpression_ = $$; }
  | Expression { $$ = new ListExpression(); $$->push_back($1); result->listexpression_ = $$; }
  | Expression _COMMA ListExpression { $3->push_back($1); $$ = $3; result->listexpression_ = $$; }
  | /* empty */ { $$ = new ListExpression(); result->listexpression_ = $$; }
  | Expression { $$ = new ListExpression(); $$->push_back($1); result->listexpression_ = $$; }
  | Expression _COMMA ListExpression { $3->push_back($1); $$ = $3; result->listexpression_ = $$; }
;
RangeExpr : UnsteppedRangeExpression { $$ = new RangeExpression($1); result->rangeexpr_ = $$; }
  | UnsteppedRangeExpression _COLON _INTEGER_ { $$ = new SteppedRangeExpression($1, $3); result->rangeexpr_ = $$; }
;
UnsteppedRangeExpression : _LPAREN RangeBody_ _RPAREN { $$ = new OpenRange($2); result->unsteppedrangeexpression_ = $$; }
  | _LBRACK RangeBody_ _RBRACK { $$ = new ClosedRange($2); result->unsteppedrangeexpression_ = $$; }
  | _LBRACK RangeBody_ _RPAREN { $$ = new LeftClosedRightOpenedRange($2); result->unsteppedrangeexpression_ = $$; }
  | _LPAREN RangeBody_ _RBRACK { $$ = new LeftOpenedRightClosedRange($2); result->unsteppedrangeexpression_ = $$; }
;
RangeBody_ : _INTEGER_ _SEMI _INTEGER_ { $$ = new RangeBody($1, $3); result->rangebody__ = $$; }
;

%%


/* Entrypoint: parse Program_* from file. */
Program_* pProgram_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program__;
  }
}

/* Entrypoint: parse Program_* from string. */
Program_* psProgram_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program__;
  }
}

/* Entrypoint: parse ListDecl* from file. */
ListDecl* pListDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdecl_;
  }
}

/* Entrypoint: parse ListDecl* from string. */
ListDecl* psListDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdecl_;
  }
}

/* Entrypoint: parse Decl* from file. */
Decl* pDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse Decl* from string. */
Decl* psDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse TypeReference* from file. */
TypeReference* pTypeReference(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typereference_;
  }
}

/* Entrypoint: parse TypeReference* from string. */
TypeReference* psTypeReference(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.typereference_;
  }
}

/* Entrypoint: parse ClassDecl* from file. */
ClassDecl* pClassDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.classdecl_;
  }
}

/* Entrypoint: parse ClassDecl* from string. */
ClassDecl* psClassDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.classdecl_;
  }
}

/* Entrypoint: parse Extends* from file. */
Extends* pExtends(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extends_;
  }
}

/* Entrypoint: parse Extends* from string. */
Extends* psExtends(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.extends_;
  }
}

/* Entrypoint: parse ListIdent* from file. */
ListIdent* pListIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse ListIdent* from string. */
ListIdent* psListIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listident_->begin(), result.listident_->end());
    return result.listident_;
  }
}

/* Entrypoint: parse FieldDef* from file. */
FieldDef* pFieldDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddef_;
  }
}

/* Entrypoint: parse FieldDef* from string. */
FieldDef* psFieldDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fielddef_;
  }
}

/* Entrypoint: parse Statics* from file. */
Statics* pStatics(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statics_;
  }
}

/* Entrypoint: parse Statics* from string. */
Statics* psStatics(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statics_;
  }
}

/* Entrypoint: parse ListFieldDef* from file. */
ListFieldDef* pListFieldDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddef_->begin(), result.listfielddef_->end());
    return result.listfielddef_;
  }
}

/* Entrypoint: parse ListFieldDef* from string. */
ListFieldDef* psListFieldDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfielddef_->begin(), result.listfielddef_->end());
    return result.listfielddef_;
  }
}

/* Entrypoint: parse CBody* from file. */
CBody* pCBody(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cbody_;
  }
}

/* Entrypoint: parse CBody* from string. */
CBody* psCBody(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cbody_;
  }
}

/* Entrypoint: parse FuncDecl* from file. */
FuncDecl* pFuncDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdecl_;
  }
}

/* Entrypoint: parse FuncDecl* from string. */
FuncDecl* psFuncDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdecl_;
  }
}

/* Entrypoint: parse FuncDefn* from file. */
FuncDefn* pFuncDefn(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdefn_;
  }
}

/* Entrypoint: parse FuncDefn* from string. */
FuncDefn* psFuncDefn(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdefn_;
  }
}

/* Entrypoint: parse FuncDomain* from file. */
FuncDomain* pFuncDomain(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdomain_;
  }
}

/* Entrypoint: parse FuncDomain* from string. */
FuncDomain* psFuncDomain(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdomain_;
  }
}

/* Entrypoint: parse FuncRange* from file. */
FuncRange* pFuncRange(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcrange_;
  }
}

/* Entrypoint: parse FuncRange* from string. */
FuncRange* psFuncRange(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcrange_;
  }
}

/* Entrypoint: parse ListTypeReference* from file. */
ListTypeReference* pListTypeReference(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtypereference_->begin(), result.listtypereference_->end());
    return result.listtypereference_;
  }
}

/* Entrypoint: parse ListTypeReference* from string. */
ListTypeReference* psListTypeReference(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtypereference_->begin(), result.listtypereference_->end());
    return result.listtypereference_;
  }
}

/* Entrypoint: parse FuncParam* from file. */
FuncParam* pFuncParam(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcparam_;
  }
}

/* Entrypoint: parse FuncParam* from string. */
FuncParam* psFuncParam(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcparam_;
  }
}

/* Entrypoint: parse FuncRangeNamed* from file. */
FuncRangeNamed* pFuncRangeNamed(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcrangenamed_;
  }
}

/* Entrypoint: parse FuncRangeNamed* from string. */
FuncRangeNamed* psFuncRangeNamed(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcrangenamed_;
  }
}

/* Entrypoint: parse ListFuncParam* from file. */
ListFuncParam* pListFuncParam(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfuncparam_->begin(), result.listfuncparam_->end());
    return result.listfuncparam_;
  }
}

/* Entrypoint: parse ListFuncParam* from string. */
ListFuncParam* psListFuncParam(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfuncparam_->begin(), result.listfuncparam_->end());
    return result.listfuncparam_;
  }
}

/* Entrypoint: parse Statement* from file. */
Statement* pStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse Statement* from string. */
Statement* psStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse StatementIf_* from file. */
StatementIf_* pStatementIf_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statementif__;
  }
}

/* Entrypoint: parse StatementIf_* from string. */
StatementIf_* psStatementIf_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statementif__;
  }
}

/* Entrypoint: parse Body_* from file. */
Body_* pBody_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.body__;
  }
}

/* Entrypoint: parse Body_* from string. */
Body_* psBody_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.body__;
  }
}

/* Entrypoint: parse Value* from file. */
Value* pValue(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse Value* from string. */
Value* psValue(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse ListStatement* from file. */
ListStatement* pListStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststatement_;
  }
}

/* Entrypoint: parse ListStatement* from string. */
ListStatement* psListStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststatement_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from file. */
Expression* pExpression10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression* from string. */
Expression* psExpression10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse FuncCall* from file. */
FuncCall* pFuncCall(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funccall_;
  }
}

/* Entrypoint: parse FuncCall* from string. */
FuncCall* psFuncCall(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funccall_;
  }
}

/* Entrypoint: parse ListExpression* from file. */
ListExpression* pListExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse ListExpression* from string. */
ListExpression* psListExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpression_->begin(), result.listexpression_->end());
    return result.listexpression_;
  }
}

/* Entrypoint: parse RangeExpr* from file. */
RangeExpr* pRangeExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rangeexpr_;
  }
}

/* Entrypoint: parse RangeExpr* from string. */
RangeExpr* psRangeExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rangeexpr_;
  }
}

/* Entrypoint: parse UnsteppedRangeExpression* from file. */
UnsteppedRangeExpression* pUnsteppedRangeExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.unsteppedrangeexpression_;
  }
}

/* Entrypoint: parse UnsteppedRangeExpression* from string. */
UnsteppedRangeExpression* psUnsteppedRangeExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.unsteppedrangeexpression_;
  }
}

/* Entrypoint: parse RangeBody_* from file. */
RangeBody_* pRangeBody_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rangebody__;
  }
}

/* Entrypoint: parse RangeBody_* from string. */
RangeBody_* psRangeBody_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = stingray__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = stingray__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  stingray__delete_buffer(buf, scanner);
  stingray_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rangebody__;
  }
}



